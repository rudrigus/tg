%TCIDATA{LaTeXparent=0,0,relatorio.tex}
                      
\chapter{Revisão Bibliográfica}\label{CapRevisaoBibliografica}

\section{Processo de Soldagem GMAW}

O processo de soldagem GMAW do inglês \textit{Gas Metal Arc Welding}, também conhecido como MIG/MAG (\textit{Metal Inert Gas/Metal Active Gas}) é um dos processos de soldagem mais propícios para automação. Alguns aspectos básicos do processo GMAW concernentes ao problema aqui tratado serão detalhados e discutidos nos próximos subitens.



\subsection{Fundamentos}

O princípio da soldagem GMAW é a união de peças metálicas é devido ao aquecimento por um arco elétrico formado entre as mesmas e um eletrodo metálico nu e consumível, sendo todos os elementos envoltos por um gás ativo ou inerte. 

O arame de soldar desempenha duas funções: por um lado é o eletrodo que conduz corrente, por outro, é também, em simultâneo, o material de adição a ser inserido na poça de soldagem. Este arame é introduzido mecanicamente através de um alimentador motorizado o que caracteriza o processo como semi-automático quando operado por humanos. \cite{book:modenesi}

A imagem \ref{fig:solda_gmaw} \cite{book:intro_soldagem}  demonstra o processo de formação do cordão de solda e seus elementos principais.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/solda_gmaw}
\caption{Elementos básicos da soldagem GMAW.}
\label{fig:solda_gmaw}
\end{figure}


Um gás de proteção que flui através do bocal da tocha protege o arco elétrico e o material em fusão, podendo o mesmo ser inerte (MIG) ou ativo (MAG). Os gases inertes, tais como o argônio e o hélio, não entram em reação com o material em fusão e apenas protegem os materiais fundidos de contaminantes. Por outro lado, os gases ativos, não só interferem no próprio arco elétrico, como também reagem com o material em fusão. Um exemplo de gás inativo é uma mistura de dióxido de carbono ou oxigênio com argônio. O componente ativo tem influência, por exemplo, sobre a penetração e/ou a temperatura do banho de fusão.

Além disto, o gás também tem influência nas perdas de elementos químicos, na temperatura da poça de fusão, na sensibilidade à fissuração e na porosidade, bem como na facilidade da execução da soldagem em diversas posições. Os gases nobres (processo MIG) são preferidos por razões metalúrgicas, enquanto o CO2 puro, é preferido por razões econômicas. O processo MAG é utilizado somente na soldagem de materiais ferrosos, enquanto o processo MIG pode ser usado tanto na soldagem de materiais ferrosos quanto não ferrosos como Alumínio, Cobre, Magnésio, Níquel e suas ligas.

% A soldagem GMAW funciona com corrente contínua (CC), normalmente com o arame no pólo positivo. Essa configuração é conhecida como polaridade reversa. A polaridade direta é raramente utilizada por causa da transferência deficiente do metal fundido do arame de solda para a peça. São comumente empregadas correntes de soldagem de 50 A até mais que 600 A e tensões de soldagem de 18V até 50V \cite{book:modenesi}. Um arco elétrico autocorrigido e estável é obtido com o uso de uma fonte de tensão constante e com um alimentador de arame de velocidade constante. A corrente de soldagem controla fortemente a velocidade de fusão do arame. Além disso, a penetração, o reforço e a largura do cordão tendem a aumentar com a corrente quando as demais variáveis são mantidas constantes.





\subsection{Equipamentos}

O processo GMAW tem um conjunto específico de equipamentos. Por ser um processo semi-automático (ou completamente automático), possui mais componentes que métodos mais convencionais de soldagem como o eletrodo revestido e o oxiacetileno. % Essa necessidade de um equipamento mais completo tem o custo compensado pela grande produtividade.

Os equipamentos necessários para esse tipo de solda são \cite{book:modenesi}:
\begin{itemize}
\item Fonte de energia

Este processo utiliza sempre corrente contínua. Dependendo do modo em que é feito o controle, pode ser necessário controlar a corrente ou a tensão fornecida pela fonte. É comum usar corrente constante ou tensão constante durante o processo;
\item Alimentador de arame

Existem diversos tipos de alimentadores com diferentes tipos de controle. O controle de alimentação do arame devem estar alinhados com o método de controle elétrico. Por exemplo: é possível usar alimentação constante de arame com tensão constante ou corrente constante e alimentação variável \cite{book:modenesi};
\item Fonte de gás protetor

Normalmente um cilindro de gás (ou gases) e reguladores de pressão e/ou vazão
\item Tocha de soldagem



Existem diferentes tipos de tocha para proporcionar o desempenho máximo na soldagem para diferentes tipos de aplicações. Elas variam desde tochas para ciclos de trabalho pesados para atividades envolvendo altas correntes até tochas leves para baixas correntes e soldagem fora de posição. Em ambos os casos estão disponíveis tochas refrigeradas a água ou secas (refrigeradas pelo gás de proteção), e tochas com extremidades retas ou curvas.

A tocha consiste em todo a aparato que é levado até o local de união das peças, seja pela mão de um operador ou uma máquina/robô. Ela contém os seguintes elementos básicos que podem ser vistos na figura \ref{fig:TochaEsquematico} \cite{book:ivanguerra}:
\begin{itemize}
\item Bocal: guia o gás para a junção, geralmente feito de cobre ou material cerâmico. Seu diâmetro deve ser compatível com a corrente de soldagem e o fluxo de gás;
\item Bico de contato: faz o contato elétrico com o eletrodo, feito de cobre;
\item Alavanca de comando ou Gatilho: Ativa a energização do circuito de soldagem, o alimentador de arame e o fluxo de gás.
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/TochaEsquematico}
\caption{Esquemático da tocha da soldagem GMAW.}
\label{fig:TochaEsquematico}
\end{figure}

\end{itemize}


%Explicar e falar por que é necessária o Monitoramento e realimentação.

\subsection{Monitoramento dos parâmetros de soldagem}

Diversas variáveis do processo GMAW podem ser ajustadas para uma boa soldagem do metal. Estas variáveis são a velocidade de alimentação do eletrodo, a distância do bocal à peça, o \textit{stickout}, a inclinação de trabalho do eletrodo, e o fluxo de gás. Essas variáveis requerem um monitoramento constante por parte do operador, ou por um equipamento automático, que é o escopo deste trabalho. A velocidade de soldagem, a posição de soldagem e o diâmetro do eletrodo também influenciam consideravelmente na geometria do cordão de solda.



\section{Processamento de imagens}
%Filtros para seleção.

As imagens obtidas no trabalho anterior de Luciano Duarte \cite{luciano},

As imagens capturadas do processo de soldagem necessitam passar por um processamento para que os valores necessários sejam obtidos. Nesta seção será explicado como é feito esse processamento.


A área de processamento de imagens desperta interesse de estudiosos por ter diversas aplicações em duas principais categorias: (1) aprimoramento de informações pictóricas para interpretação humana; e (2) extração automática de dados relevantes à partir de uma cena \cite{oge}. A segunda categoria, que será utilizada neste trabalho, também pode ser designada como ''análise de imagens'', ''visão por computador'' ou ''reconhecimento de padrões''.

Diversas áreas se beneficiam de técnicas de processamento de imagens. Na medicina procedimentos computacionais melhoram o contraste, codificam níveis de intensidade para melhor interpretação e podem até mesmo calcular a quantidade de uma determinada célula em uma imagem. Geógrafos fazem uso de técnicas semelhantes e podem determinar áreas de vegetação, desmatamento, e poluição \cite{gonzalez}. Existem muitos outros exemplos, que vão até o controle de qualidade e de processos.

\subsection{Elementos de sistemas de processamento de imagens}
Um sistema de processamento de imagens consiste alguns elementos básicos mostrados a seguir:
\begin{enumerate}
\item {Aquisição:

São necessários: um dispositivo físico sensível a uma faixa de frequência no espectro eletromagnético (preferencialmente a luz visível) que produza um sinal elétrico proporcional ao nível de energia detectado; e um digitalizador que converte o sinal elétrico analógico em um sinal digital.
}
\item{Armazenamento:

Um desafio em processamento de imagens, o armazenamento de imagens digitais requer muita memória RAM ou \it{frame buffers} (Armazenamento por curto tempo) e espaço em disco (Arquivamento). \textbf{Apesar de os computadores atuais não terem grandes problemas com armazenamento, alguns equipamentos podem não ter memória suficiente para a tarefa como, por exemplo, um microcontrolador.}
}

\item{Processamento:

É um procedimento algorítmico que normalmente é realizado via software. Em casos em que velocidade é um fator importante no processamento pode ser necessário o uso de hardware especializado. É a parte mais complexa do sistema, exige pesquisa e desenvolvimento. 
}
\item{Comunicação:

A transmissão de imagens digitais necessita de uma alta largura de banda. Técnicas de compressão de imagens costumam ser utilizadas para reduzir este problema. Em aplicações em tempo real é necessária a sincronização dos dados.
}
\item{Exibição:

Por fim, o resultado do processamento é exposto ao ser humano através de um monitor. Pode ser desnecessária a exibição de todas as imagens de um processo que for automático.
}

\end{enumerate}

O elemento mais importante neste trabalho, Processamento de Imagens,possui alguns passos fundamentais para se chegar ao objetivo proposto. São eles:

\begin{enumerate}
\item{\textbf{Pré-processamento}: tem por objetivo melhorar a qualidade da imagem para que os estágios seguintes tenham mais garantia de sucesso. Geralmente envolve técnicas de realce de contrastes, remoção de ruído e isolamento de regiões.
}
\item{\textbf{Segmentação}: é a divisão da imagem pré-processada em partes ou objetos constituintes. Por exemplo, caracteres em uma imagem de texto. É uma das tarefas mais difíceis de se implementar  e geralmente é o que define se o processamento vai ter sucesso ou não.
}
\item{\textbf{Representação e descrição}: nesse estágio, os dados obtidos pela segmentação em forma de pixels passam a ser representados de forma fronteiras e/ou  regiões completas. A partir dessa representação, há a descrição de características quantitativas ou qualitativas, por exemplo, uma concavidade ou um buraco.
}
\item{\textbf{Reconhecimento e interpretação}: finalmente, os objetos descritos anteriormente devem ser reconhecidos como algum padrão ou um valor para então se fazer a interpretação de um conjunto de objetos reconhecidos e atribuir um significado a esse conjunto. Por exemplo, uma imagem da palavra ''sim'' deve conter os objetos reconhecidos como ''s'',''i'', ''m'' e ser interpretada com a palavra ''sim''.
}
\end{enumerate}

\begin{figure}[h]
\begin{center}
\includegraphics[scale = 0.7]{./Figuras/passos_fundamentais.jpg}
\caption{Passos Fundamentais em processamento de imagens digitais}\label{fig:passos_fundamentais}
\end{center}
\end{figure}

Todos esses passos são possíveis quando se tem uma \textbf{Base de conhecimento} prévia que fica codificada no sistema de processamento de imagens. Com esses conhecimentos sobre o problema em questão e os métodos disponíveis pode-se criar uma solução viável. Por exemplo, quando é conhecida a região da imagem que tem informações de interesses é mais fácil segmentar essa imagem.

\subsection{Realce de imagens}

O objetivo das técnicas de realce é obter uma imagem mais apropriada para uma aplicação específica por meio de técnicas de processamento. As técnicas escolhidas, assim como seus parâmetros e a ordem em que são aplicadas dependem completamente da aplicação.
Existem basicamente dois métodos de realce: \textbf{Métodos no domínio espacial} e \textbf{Métodos no domínio da frequência}.

Os métodos no domínio espacial operam diretamente sobre o agregado de pixels que compõem uma imagem. Funções de processamento de imagens no domínio espacial podem ser expressas como:

\begin{equation}
g(x,y)=T[f(x,y)]
\end{equation}

em que $f(x,y)$ é a imagem de entrada, $g(x,y) $ é a imagem processada e $T$ é um operador sobre $f$, definido sobre alguma vizinhança de $(x,y)$. $T$ pode operar sobre um conjunto de imagens de entrada, como será explicado mais adiante.

A estratégia é definir uma subimagem em torno de um pixel $(x,y)$ (quadrado, retângulo ou mesmo aproximação de um círculo) e aplicar a operação sobre essa subimagem para cada pixel da imagem e obter $g$ em cada posição correspondente. A vizinhança mais simples que pode ser definida tem tamanho $1\times 1$, e $T$ é uma \textit{trasformação de níveis de cinza} ou \textit{processamtento ponto-a-ponto} da forma:

\begin{equation}
s=T(r)
\end{equation}

em que $r$ e $s$ representam os níveis de cinza de $f(x,y)$ e $g(x,y)$, respectivamente. Este tipo de função permite operações como mudança de contraste, binarização de imagem ou limiarização.
Outra variedade de funções pode ser aplicada sobre a imagem ao se trabalhar vizinhanças maiores. Costuma-se utilizar uma janela ou \textit{máscara} em forma de matriz $3\times 3$ para se fazer operações. Essa técnica costuma ser chamada de \textit{filtragem}.

Os métodos no domínio da frequência se baseiam no teorema da convolução com um operador linear invariante com a posição $h(x,y)$ na forma:

\begin{equation}
g(x,y) = h(x,y)*f(x,y)
\label{eq:convolucao}
\end{equation}

ou, a partir do teorema da convolução, no domínio da frequência:

\begin{equation}
G(u,v)=H(u,v)F(u,v)
\end{equation}

em que $G$, $H$ e $F$ são transformadas de Fourier de $g$, $h$ e $f$, respectivamente. Similarmente aos sistemas lineares, a transformada $H(u,v)$ é chamada de \textit{função de transferência óptica}. A equação \ref{eq:convolucao} é um processo espacial análogo ao uso de máscaras e $h(x,y)$ costuma ser chamada de \textit{máscara de convolução espacial}.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale = 0.7]{Figuras/convolucao.png}
\caption{Máscara e vizinhança de pixel}\label{fig:convolucao}
\end{center}
\end{figure}

A seguir são detalhados os métodos de processamento utilizados neste trabalho.

\subsubsection{Limiarização}

Esta é um método espacial que consiste em separar uma imagem em diferentes níveis de cinza. O comum é ter apenas um limiar e dois níveis, o que constitui em uma binarização da imagem. A binarização pode ser feita de duas formas: transformar todos os pixels abaixo de um limiar em zero (preto) ou transfomar todos os acima do limiar no nível máximo (branco). 



\subsection{Distorção de perspectiva}

Imagens de objetos tridimensionais capturados por uma câmera podem ter suas dimensões distorcidas pois a imagem é uma projeção bidimensional de parte do objeto. Essa distorção pode tornar impossível a tarefa de medir corretamente dimensões do objeto em questão. 

A projeção que ocorre no caso de captura de imagem por uma câmera é do tipo cônica, e não cilíndrica, isso implica que objetos de dimensões iguais no mundo real que estejam a diferentes distâncias da câmera terão suas projeções com diferentes tamanhos na imagem. Além disso câmeras podem ficar em ângulos oblíquos em relação aos planos de interesse dos objetos e essa projeção oblíqua pode resultar em diferentes medidas em diferentes eixos.

Para eliminar o problema de distorção existem dois métodos comumente utilizados: visão estereoscópica e transformação de projeção. O método de visão estereoscópica, apesar de permitir gerar um objeto tridimensional virtual, foi descartado neste trabalho pois seria tecnicamente inviável. Em ambientes com um razoável controle, como manter a câmera fixa em relação ao objeto, a transformação de projeção é suficiente para se obter os dados necessários.

\begin{figure}[h!]
\begin{center}
\subfigure[\label{fig:ModeloPlanoCamera}]{
\includegraphics[scale = 0.7]{Figuras/ModeloPlanoCamera.jpg}}
\subfigure[\label{fig:Modelo1DimCamera}]{
\includegraphics[scale = 0.7]{Figuras/Modelo1DimCamera.jpg}}
\caption{ (a) Modelo de câmera plana. (b) Modelo de câmera unidimensional.}\label{fig:ModeloCamera}
\end{center}
\end{figure}


\subsubsection{Coordenadas Homogêneas}

Matematicamente o modelo de câmera e de projeção pode ser definido por uma matriz de transformação $H$. Pontos do plano real, $\Pi$  são representados por vetores em letra maiúscula, $\textbf{X}$, e as imagens correspondentes, no plano $\pi$ são representadas por vetores de letra minúscula, $\textbf{x}$. A projeção de perspectiva dos pontos correspondentes é dada por \cite{chapter:Zisserman:23} :


\begin{equation}
\textbf{X} = T\textbf{x}
\end{equation}\label{eq:ModeloCamera}

Onde $T$ é uma matriz $3 \times 3$, ''$= $''  representa igualdade em escala. Os vetores de pontos são dados por: $\textbf{X} = (X_1,X_2,X_3)^T$ e $\textbf{x} = (x_1,x_2,x_3)^T$


O ponto da imagem, uma projeção, e representado por três coordenadas cartesianas, $\textbf{x} = (x_1,x_2,x_3)^T$. Essas coordenadas são chamadas de homogêneas. Apenas a direção do vetor é importante visto que, independente da distância da câmera, qualquer ponto real em determinada direção aparecerá em um único ponto na projeção. Portanto todos os pontos da forma $ \lambda \textbf{x} = (\lambda x_1, \lambda x_2, \lambda x_3)$ são equivalentes.

Para representar os pontos em um plano cartesiano convencional da forma $(x,y)$, deve-se construir um plano especial $\pi_e)$, perpendicular ao eixo $x_3$ a uma distância unitária na direção de $x_3$. A intersecção do vetor $\textbf{x}$ com o plano $\pi_e$ é o ponto $x_e = (x,y,1)$.

É de interesse que a posição desse plano não afete a posição das coordenadas cartesianas $(x,y)$, portanto define-se essas coordenadas da seguinte forma:

\begin{equation*}
x_e = (\frac{x_1}{x_3},\frac{x_2}{x_3},1)^T = (x,y,1)^T
\end{equation*}



O modelo da câmera é completamente especificado pela matriz $T$, que pode ser calculada com a posição relativa dos dois planos e o ponto focal da câmera. Porém, essa matriz também pode ser calculada diretamente por correspondência entre pontos na imagem e pontos no mundo real. Esse cálculo é descrito na seção \ref{section:CalculoMatrizTransf}.



\subsubsection{Cálculo da matriz de transformação}\label{section:CalculoMatrizTransf}


A equação \ref{eq:ModeloCamera} pode ser melhor visualizada a seguir:

\begin{equation*}
\begin{bmatrix} 
x_1 \\
x_2 \\
x_3
\end{bmatrix} 
 =
\begin{bmatrix} 
t_{11} & t_{12} & t_{13} \\
t_{21} & t_{22} & t_{23} \\
t_{31} & t_{32} & t_{33}
\end{bmatrix} 
\begin{bmatrix}
X_1 \\
X_2 \\
X_3
\end{bmatrix} 
\end{equation*}


A escala $\lambda$ da matriz não afeta a equação, portanto apenas os oito graus de liberdade correspondentes à razão dos elementos da matriz são significantes.

À partir da equação \ref{eq:ModeloCamera},cada correspondência entre pontos reais e pontos da imagem gera duas equações de coordenada cartesianas $\textbf{H}$. Para $n$ correspondências obtém-se um sistema com $2n$ equações com $8$ variáveis. Se $n = 4$, obtém-se a solução exata \cite{chapter:Zisserman:23}. Se $n > 4$, a matriz  é super-determinada e estima-se $\textbf{H}$ por minimização \cite{article:Criminisi}.%
% % MUITO IMPORTANTE!!! Significa que são necessários 4 pontos conhecidos no mundo real. Posso colocar uma escala sobre a peça para obter o modelo da câmera e fazer uma pré calibração

A representação em coordenadas cartesianas demonstra a natureza não linear da transformação:

\begin{eqnarray}
x = \frac{x_1}{x_3} = \frac{t_{11}X + t_{12}Y + t_{13}}{t_{31}X + t_{32}Y + t_{33}} \\
y = \frac{x_2}{x_3} = \frac{t_{21}X + t_{22}Y + t_{23}}{t_{31}X + t_{32}Y + t_{33}}
\end{eqnarray}

Para definir os elementos da matriz de transformação deve-se ter quatro correspondências de pontos entre plano real e projeção. Com a escala de $\textbf{T}$ arbitrária, e $t_{33}=1$, temos os pontos representados por $(\lambda_i x_i, \lambda_i y_i, lambda_i)^T = T(X_i,Y_i,1)^T$. O sistema de equações lineares resultantes é:

\begin{equation}
\begin{bmatrix}
X_1 & Y_1 & 1 & 0 & 0 & 0 & -x_1 X_1 & -x_1 Y_1 \\
0 & 0 & 0 & X_1 & Y_1 & 1 & -y_1 X_1 & -y_1 Y_1 \\
X_2 & Y_2 & 1 & 0 & 0 & 0 & -x_2 X_2 & -x_2 Y_2 \\
0 & 0 & 0 & X_2 & Y_2 & 1 & -y_2 X_2 & -y_2 Y_2 \\
X_3 & Y_3 & 1 & 0 & 0 & 0 & -x_3 X_3 & -x_3 Y_3 \\
0 & 0 & 0 & X_3 & Y_3 & 1 & -y_3 X_3 & -y_3 Y_3 \\
X_4 & Y_4 & 1 & 0 & 0 & 0 & -x_4 X_4 & -x_4 Y_4 \\
0 & 0 & 0 & X_4 & Y_4 & 1 & -y_4 X_4 & -y_4 Y_4 \\
\end{bmatrix}
\begin{bmatrix}
t_{11}\\
t_{12}\\
t_{13}\\
t_{21}\\
t_{22}\\
t_{23}\\
t_{31}\\
t_{32}\\
\end{bmatrix}
=
\begin{bmatrix}
x_1\\
y_1\\
x_2\\
y_2\\
x_3\\
y_3\\
x_4\\
y_4\\
\end{bmatrix}
\end{equation}\label{eq:SistEqZisserman}

Esse sistema linear garante a solução para a matriz $\textbf{T}$, desde que nenhum grupo de três pontos sejam colineares.

\subsubsection{Minimização de erros da transformação}

Para que se minimize as margens de erro da matriz de transformação $\textbf{T}$, são necessários mais de quatro correspondências de pontos. De modo geral, como demonstrado em \cite{article:Criminisi}, quanto mais pontos utilizados na determinação da matriz de transformação, menor é a incerteza. Para $n$ pontos, sistema de equações é semelhante à \ref{eq:SistEqZisserman}:

\begin{equation}
\begin{bmatrix}
X_1 & Y_1 & 1 & 0 & 0 & 0 & -x_1 X_1 & -x_1 Y_1 \\
0 & 0 & 0 & X_1 & Y_1 & 1 & -y_1 X_1 & -y_1 Y_1 \\
X_2 & Y_2 & 1 & 0 & 0 & 0 & -x_2 X_2 & -x_2 Y_2 \\
0 & 0 & 0 & X_2 & Y_2 & 1 & -y_2 X_2 & -y_2 Y_2 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
X_n & Y_n & 1 & 0 & 0 & 0 & -x_n X_n & -x_n Y_n \\
0 & 0 & 0 & X_n & Y_n & 1 & -y_n X_n & -y_n Y_n \\
\end{bmatrix}
\begin{bmatrix}
t_{11}\\
t_{12}\\
t_{13}\\
t_{21}\\
t_{22}\\
t_{23}\\
t_{31}\\
t_{32}\\
\end{bmatrix}
=
\begin{bmatrix}
x_1\\
y_1\\
x_2\\
y_2\\
\vdots \\
x_n\\
y_n\\
\end{bmatrix}
\end{equation}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsection{Detecção de cantos}\label{section:DeteccaoCanto}

Muitas tarefas em processamento de imagens requerem a identificação de elementos em imagens, como figuras geométricas, linhas e pontos. Existem diversos métodos e algorítimos para detecção de cantos, mas apenas o método de Harris \cite{article:Harris} será descrito nessa seção pois apresenta alta taxa de acerto e fácil implementação de paralelismo, que pode acelerar o processo em um FPGA.

\subsubsection{Detector de Moravec}

O algorítimo parte do princípio de diferenciação intensidade em porções de imagens usado no detector de imagens de Moravec \cite{article:Moravec}. O detector de Moravec funciona considerando uma janela na imagem, e determina a mudança de intensidade da imagem que resulta do deslocamento dessa janela em várias direções. São feitas as seguintes considerações:

\begin{enumerate}
\item Se a imagem na janela é plana, (aproximadamente constante em intensidade), então todas os deslocamentos resultam em uma mudança pequena;
\item Se a janela de move ao longo de uma borda, então a mudança de intensidade é pequena, mas se o deslocamento for perpendicular à borda, a mudança é grande;
\item Se a janela contém um canto ou ponto isolado, então todas os deslocamentos resultam em uma grande mudança de intensidade. Portanto, um canto pode ser detectado quando a menor mudança produzida por qualquer deslocamento for grande.
\end{enumerate}

Foi feita a descrição matemática das considerações acima. Denotando as intensidades como $I$, a mudança $E$ produzida por um deslocamento $(x,y)$ é dado por:

\begin{equation}
E_{x,y} = \sum\limits_{u}^{v} w_{u,v} | I_{x+u,y+v} - I_{u,v} |^2
\end{equation}

onde $w$ especifica a janela da imagem: é uma unidade dentro de uma região retangular específica, e zero fora dela. Os deslocamentos $(x,y)$, são do tipo ${(1,0),(1,1),(0,1),(-1,1)}$. Portando o detector de Moravec é basicamente: procurar por um máximo local em $min(E)$ acima de uma limite estabelecido.

\subsubsection{Detector de auto-correlação}

A performance do detector de Moravec contém uma série de erros conforme demonstrado em \cite{article:Harris}, que então os listou e fez as devidas correções:

\begin{enumerate}
\item \textbf{A resposta é anisotrópica porque apenas um grupo de deslocamentos discretos é considerado} - todos os possíveis deslocamentos podem ser cobertos fazendo uma expansão analítica em torno do centro de deslocamento.
\begin{equation}
E_{x,y} = \sum\limits_{u}^{v} w_{u,v} [I_{x+u,y+v} - I_{u,v}] ^2
= \sum\limits_{u}^{v} w_{u,v} [x X + y Y + O(x^2,y^2)]^2
\end{equation}

onde os primeiros gradientes são aproximados por
\begin{eqnarray*}
X = I \otimes (-1,0,1) \approx \delta I/\delta x
\\Y = I \otimes (-1,0,1)^T \approx \delta I/\delta y
\end{eqnarray*}

Então para pequenas mudanças, $E$ pode ser escrito
\begin{equation*}
E(x,y) = A x^2 + 2C x y + B y^2
\end{equation*}

onde
\begin{eqnarray*}
A = X^2 \otimes w
\\B = Y^2 \otimes w
\\ C = (X Y) \otimes w
\end{eqnarray*}

\item \textbf{A resposta é ruidosa porque a janela é binária e retangular} - usar uma janela circular suave, por exemplo uma Gaussiana:
\begin{equation*}
w_{u,v} = exp -(u^2+v^2)/2 \sigma^2
\end{equation*}

\item \textbf{O operador responde muito cedo a bordas porque o apenas o mínimo de $E$ é considerado} - reformular a medida de canto para usar a variação de $E$ com a direção do deslocamento. A mudança, $E$, para um pequeno deslocamento $(x,y)$ pode ser escrita como:
\begin{equation*}
E(x,y) = (x,y) M (x,y)^T
\end{equation*}

onde a matriz $M$, $2 \times 2$  simétrica é:
\begin{equation}
M = \begin{bmatrix}
A & C
\\ C & B
\end{bmatrix}
\end{equation}
\end{enumerate} 

Os autovalores $\alpha$ e $\beta$ de $M$ correspondem à principais curvaturas da função de autocorrelação local. São três os casos em relação aos autovalores:

\begin{enumerate}
\item Se ambos são pequenos, a janela corresponde a uma imagem plana;
\item Se um é pequeno e o outro é grande, a janela corresponde a uma borda;
\item Se ambos são grandes, a janela corresponde a um canto.
\end{enumerate}

Com essas três considerações, se faz necessário uma medida também uma medida de qualidade de cantos. Calcula-se então uma medida $R$, função de $/alpha$ e  $/beta$. Para evitar a decomposição dos autovalores de $M$, usa-se o traço e a determinante da matriz, sendo que:
\begin{eqnarray*}
Tr (M) = \alpha + \beta = A + B
\\ Det (M) = \alpha \beta = A B - C^2
\end{eqnarray*}

Finalmente, Harris usou a seguinte formulação:
\begin{equation}
R = Det (M) - k Tr (M)^2
\end{equation}

Com essa formulação, pode-se definir o tipo da região localizada em $(u,v)$:

\begin{Bitemize}
\item Canto, se $R$ é positivo;
\item Borda, se $R$ é negativo;
\item Região plana, se $R$ é pequeno.
\end{Bitemize}

Como $R$ pode assumir uma grande gama de valores, positivos e negativos, usa-se um limite inferior e um limite superior 

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 



\section{Sistemas reconfiguráveis}

Os custos para se testar circuitos na indústria de eletrônicos são muito elevados, pois é necessário fazer todo o \textit{setup} do processo de produção para um novo circuito. Por esse motivo foi desenvolvida a FPGA, ou \textit{Field Programable Gate Array}, que é um circuito reconfigurável que pode rapidamente assumir as características de um circuito digital, com todas as suas ligações e portas lógicas.

\subsection{História}

Os primeiro dispositivo programáveis foi o \textit{Programmable Read Only Memory}(PROM) , uma memória não volátil que podia ser do tipo fabricado em massa ou programável em campo pelo usuário. Por sua vez o tipo o PROM reconfigurável em campo tinha duas dubdivisões: EPROM (\textit{Erasable} PROM) e EEPROM (\textit{Electronic Erasable} PROM), que pode ser reprogramado múltiplas vezes. Em seguida foram criados os \textit{Programmable Logic Devices} (PLDs), em que o tipo mais comum implementa um conjunto fixo de portas OR precedido por uma matriz de portas AND programáveis. \cite{online:Wayback}

Em 1985, a empresa Altera criou o primeiro dispositivo reprogramável da indústria, o chip EP300, Os usuários poderiam apagar as células EPROM do EP300 ao emitir luz ultravioleta através de uma janela de quartzo acima do circuito. A opção meramente conveniente à época se mostraria um grande fator na indústria.
%citar Altera - In The Begining, online

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/ep300.jpg}
\caption{EP300 da Altera}
\label{fig:ep300}
\end{figure}


As FPGAs foram desenvolvidas como uma evolução dos PLDs, mais especificamente dos PLAs \textit{Programmable Logic Arrays} (PLAs), como descrito em \cite{page1985re}. Em 1985 a empresa Xilinx criou a primeira FPGA comercial \cite{freeman1989configurable},  com portas e interconexões reprogramáveis.
Contudo, foi durante a década de 1990 que esses dispositivos ficaram famosos e assumiram diversas aplicações.
%citação xilinx

Atualmente os sistemas reconfiguráveis continuam em alta, principalmente agora que as tecnologias de fabricação estão próximas do limite de miniatuzação. O poder de processamento de arquiteturas convencionais (Arquitetura de von Neumann), baseadas em um \textit{hardware} genérico que recebe fluxos de instruções, demonstra desaceleramento. 
% citar Gordon moore at Intel Developer Forum
Com o esperado limite da Lei de Moore 
% citar Gordon_Moore, Cramming more components onto integrated circuits
, muitos projetistas recorrem ao uso de \textit{hardware} específico para solucionar diferentes problemas. 

As FPGAs atuais são produzidas com uma série de facilidades que incluem: memória, entradas e saídas de alta velocidade e blocos lógicos. Elas podem tanto ser utilizadas para desenvolvimento e teste de circuits digitais (motivo pelo qual foram desenvolvidas) como podem ser implementadas no produto final. As aplicações vão desde processamento de imagens a mineração de \textit{bitcoins}

\section{Aspectos Gerais}

De acordo com \cite{page1985re} os \textit{Programmable Gate Array} (PLAs) reconfiguráveis são descritos abaixo:
%traduzir
In general, a PLA is a logic circuit which receives a plurality of digital input signals and generates a plurality of digital output signals wherein each of the digital output signals is a programmable sum-of-product combination of the input signals. In conventional PLA?s, one circuit is provided for generating a plurality of terms which are the logical AND of selected input signals; and another circuit is provided to generate the output signals by selectively ORing the AND terms. A typical PLA may have a total of x input signals, generate a total of y AND terms from the input signals, and generate a total of 2 output signals by selectively ORing the y AND terms.




Outras tecnologias de semicondutores reprogramáveis também foram desenvolvidas, como os  \textit{Application Specific Integrated Circuits} (ASICs), onde o dispositivo é desenvolvido apenas para um tipo de aplicação. Ainda há uma subdivisão dentro das FPGAs:

\begin{Bitemize}
\item \textit{One-Time Programmable} (OTP), que funciona como um ASIC depois de programado;
\item SRAM-\textit{based}, que pode ser reconfigurado múltiplas vezes e é o tipo mais utilizado.
\end{Bitemize}

O FPGA é um arranjo de CLBs (\textit{Configurable Logic Blocks}) e IOBs(\textit{In/Out Blocks}) ligados por chaves de interconexão, também reconfiguráveis. O CLB é a unidade básica do FPGA e consiste de uma matriz de seleção configurável com quatro ou seis entradas, um circuito de seleção (como um multiplexador), e Flip-Flops.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/esquemaCLB_FPGA.jpg}
\caption{Exemplo de esquema de ligação de CLBs e IOBs em uma FPGA}
\label{fig:esquemaCLB_FPGA}
\end{figure}

\begin{verbatim}
https://en.wikipedia.org/wiki/Field-programmable_gate_array#cite_note-book-16
file:///home/rodrigo/Downloads/US4508977.pdf
https://www.google.com/patents/US8112466?dq=field+programmable+gate+array+patent&hl=pt-BR&sa=X&ved=0CCQQ6AEwAWoVChMIwYequJ2VyAIVyA2QCh26Iw5V
https://www.google.com/patents/US4870302?dq=freeman+1989+configurable&hl=pt-BR&sa=X&ved=0CBsQ6AEwAGoVChMI-O2cw5OVyAIVhoyQCh07Cgcw
https://www.google.com.br/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8&client=ubuntu#q=patent%20fpga

\end{verbatim}


\section{Linguagens de Descrição de Hardware e VHDL}

Uma linguagem de descrição de hardware, ou HDL (\textit{Hardware Description Language}) é semelhante a uma linguagem de programação em termos de sintaxe e estrutura, porém como o próprio nome diz ela serve mais para descrever do que para programar. Esse tipo de linguagem tem por objetivo facilitar o projeto de circuitos eletrônicos, com uma descrição formal e precisa. Uma HDL padronizada permite a intercambialidade de informações entre diferentes fabricantes e projetistas além da automatização de simulação e síntese de circuitos. Existem variadas HDLs, dentre as quais foi escolhida a VHDL para este trabalho por motivos a serem expostos adiante.

\subsection{História do VHDL}

O surgimento do VHDL se deve à necessidade do \textit{Defense Advanced Research Projects Agency} (DARPA) em desenvolver uma ferramenta de projeto e documentação para o projeto VHSIC (\textit{Very High Speed Integrated Circuit}). O Departamento de Defesa definiu em 1983 os requisitos para uma linguagem de descrição padrão para circuitos e contratou as empresas IBM, Texas e Intermetrics para a tarefa. \cite{book:Amore}

A linguagem foi padronizada pelo IEEE (\textit{Institute of Electrical and Electronic Engineers}) com base na versão 7,2 e com o auxílio da empresa CLSI, contratada pela Força Aérea dos Estados Unidos. \cite{book:Amore} Em 1987, surgiu o padrão IEEE 1076-1987, denominado VHSIC \textit{Hardware Description Language} ou VHDL. A padronização da linguagem contou com a participação de profissionais de diversas áreas: design de sistemas de computadores, aeroespacial, comunicações, desenvolvedores de CAD, desenvolvimento de circuitos integrados etc. \cite{ieeeVHDL87}

Em 1993, o padrão 1076 recebeu uma revisão para facilitar ainda mais o trabalho de projetistas. A principal mudança era o melhor gerenciamento hierárquico de arquivos \cite{ieeeVHDL93-1076}. No mesmo ano surgiu o padrão 1164, que definia o pacote ''std\_logic\_1164'' que trouxe mais versatilidade ao modelamento por representar mais condições reais como alta impedância e nós não inicializados. O padrão 1164 é muito utilizado até os dias de hoje, principalmente depois de suas revisão em 2008 .

Em 1997, o surgiu mais um padrão, o 1076.3 \cite{ieee1997-1076.3}, que propôs novos tipos de dados como inteiros e reais, e novas funções como soma e multiplicação. Esses tipos são abstratos em código e um mero conjunto de bits no circuito real, porém a linguagem permite as operações apenas com variáveis de mesmo tipo. Essa padronização caracteriza o VHDL como uma linguagem fortemente tipada.



\subsection{Aspectos gerais da VHDL}

A linguagem VHDL, pode ser entendida tanto por máquinas quanto por humanos como na própria definição do IEEE \cite{ieee1997-1076.3}. Tem por objetivo organizar e documentar os projetos para diminuir o tempo de trabalho dos projetistas além de promover a rápida sintetização e de simulação de circuitos.

Uma das suas principais características é a alta hierarquização. É possível criar projetos com múltiplos níveis de hierarquia utilizando entidades (descrições de circuitos) dentro de entidades. Essa estrutura facilita o desenvolvimento partindo de níveis mais altos de abstração para níveis menores, com o método chamado \textit{top down} (muito comum nas linguagens de programação mais recentes). Também é usada a descrição do comportamento esperado do circuito.

Em um circuito sintetizado, a maioria dos comandos é executado concorrentemente, independente do nível hierárquico dos componentes e da ordem em que são declarados. No exemplo da figura \ref{fig:exemplo_concorrencia} 

%\begin{figure}[h]
%\centering
%\includegraphics[width=\textwidth]{./Figuras/exemplo_concorrencia.jpg}
%\caption{Concorrência de comandos}
%\label{fig:exemplo_concorrencia}
%\end{figure}

Apesar disso é possível criar operações sequenciais tais como linguagens de programação em regiões específicas do código, nos subprogramas e processos. Essas estruturas são muito úteis para operações específicas como operações aritméticas mais complexas.

Algumas das características principais da linguagem são:

\begin{Bitemize}
\item \textit{Case-insensitive}, ou seja não identifica diferença entre caixa alta ou baixa em seu código;
\item Fortemente tipada;
\item Escalonável;
\item Hierárquica
\end{Bitemize}


\subsection{Entidades}

É uma abstração primária do VHDL.  As entidades podem ser instanciadas dentro de outras entidades, formando assim a hierarquia do projeto. Cada instância é vista pela entidade superior como uma caixa preta da qual se conhece apenas as entradas e saídas. A ferramenta de sintetização cria as instâncias à partir do nível mais alto da hierarquia, a Entidade de Projeto (ou \textit{Top Level Entity}).

Cada entidade ser declarada com a palavra reservada ''ENTITY'' seguida do nome que a identifica. Em seguida podem ser opcionalmente declaradas as cláusulas \textbf{}PORT'' ou ''GENERIC''. A cláusula ''PORT'' define os tipos de portas de entrada e saída da entidade. A cláusula ''GENERIC'' permite passar informações estáticas para uma entidade. Essas cláusulas são opcionais e podem ser omitidas, por exemplo em um \textit{testbench} usado para simulações.

%Cada porta tem um modo que define a direção e como os comandos na arquitetura podem operar com essas portas. Os modos são: ''in'', ''out'', ''buffer'', ''inout''.

O comportamento de uma entidade é definido pela arquitetura e precisa ser declarado com a palavra ''ARCHITECTURE''  seguida do nome dado a arquitetura e a identificação da entidade a qual ela está definindo. Em seguida, podem ser declarados sinais, constantes, subprogramas ou identificação de outras entidades que serão instanciadas dentro desta. Finalmente, a lógica  é descrita entre as palavras ''BEGIN'' e ''END'' da arquitetura, com todos os comandos, as operações e instanciações.

O exemplo abaixo mostra uma entidade que utiliza a instância de outras em seu código:

\begin{verbatim}
LIBRARY ieee ;
USE ieee.std_logic_1164.all ;
USE ieee.std_logic_arith.all;

ENTITY main is
    port (  CLOCK : in std_logic;
    start_stop  : in std_logic ;
            up_down       : in std_logic ;
    D1A, D1B, D1C, D1D, D1E, D1F, D1G, DP1 : out std_logic;
  );
        
        
END main ;

ARCHITECTURE ESTRUTURA of main is

SIGNAL BCD : std_logic_vector(3 downto 0);
SIGNAL binario4bits : integer(11 downto 0);
COMPONENT CONTADOR
PORT  ( 
  CLK   : in std_logic;
  start_stop    : in std_logic ;
    up_down     : in std_logic ;
  binario4bits  : out integer(3 downto 0)
  );
END component;

COMPONENT BIN_7SEG
PORT  ( 
  BIN : in std_logic_vector(3 downto 0);
  SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G, DP : out std_logic
  );
END component;

BEGIN
conta1 : CONTADOR port map (CLOCK, start_stop, up_down, binario12bits);
conv1 : BIN_7SEG port map (binario4bits, D1A, D1B, D1C, D1D, D1E, D1F, D1G, DP1);
END ESTRUTURA;

\end{verbatim}



\subsubsection{Entidade de Projeto}

A entidade de projeto ou \textit{top level entity} é o nível mais alto na hierarquia de um projeto VHDL. Por convenção, o documento dessa entidade geralmente leva o nome do projeto e é por este documento que a ferramenta de sintetização começa a leitura.

Assim como outras entidades, a entidade de projeto tem entradas e saídas de diferentes tipos, porém estas não são utilizadas por outras entidades pois esta não está contida em nenhuma outra. As portas declaradas para essa entidade são diretamente relacionadas com o ambiente externo ao dispositivo. Por exemplo: são as portas desta entidade que o sintetizador usa para mapear os pinos de uma placa FPGA. Todas as outras portas de outras entidades são sinais internos à placa neste caso.

A arquitetura da entidade de projeto define o comportamento geral de todo o circuito, com as principais entidades que serão instanciadas e o relacionamento entre as mesmas. Em grandes projetos é comum não haver operações nesta entidade, somente ligações entre outras entidades e entre estas com o meio exterior.






\subsection{Bibliotecas e Pacotes}

O VHDL faz uso de bibliotecas para reaproveitar códigos e padronizar os projetos. Existem bibliotecas padrão como a IEEE, que possui diversos pacotes, como o 1076.3 e o 1164, que geralmente podem ser usados em um mesmo projeto. O projetista também pode definir bibliotecas próprias para fins de organização ou uso em outros projetos.

A maioria das bibliotecas precisam ser declaradas no início do código com a palavra chave ''LIBRARY'' para se ter acesso a suas definições e pacotes. Há duas bibliotecas que estão sempre disponíveis automaticamente sem necessidade de declaração nos documentos: a biblioteca padrão ''std'' e a biblioteca ''work''.

Os pacotes são definições que podem ser utilizadas em diferentes modelos definidos em diferentes arquivos e estão sempre contidos em alguma biblioteca. É um recurso que permite reutilizar código para poupar tempo e principalmente para manter a padronização de projetos. Em uma linguagem fortemente tipada, como é o caso do VHDL, é de suma importância a utilização de pacotes em detrimento de definições locais.

Existem diversos pacotes padrões, muitos dos quais distribuídos pelo IEEE, mas também há os pacotes definidos pelo próprio projetista como citado anteriormente.

Cada pacote utilizado precisa ser declarado no início do documento para se ter acesso aos elementos definidos no mesmo ao longo do código. É necessário declarar de antemão a biblioteca em que o pacote está contido, caso não esteja nas bibliotecas ''std'' ou ''work''. O exemplo abaixo permite acesso aos tipos e operações do pacote 1164 da IEEE:

\begin{verbatim}
LIBRARY ieee;
USE ieee.std_logic_1164;
\end{verbatim}

Pacotes definidos pelo usuário precisam ser claramente identificados pela palavra chave ''package'' e ficam disponíveis para seus documentos dentro da biblioteca ''work'', a não ser que sejam explicitamente declaradas dentro de outra biblioteca definida pelo usuário. O exemplo abaixo mostra a declaração e utilização de um pacote:

\begin{verbatim}
PACKAGE meu_pacote IS
  TYPE \textbf{meu_inteiro} IS range -127 to 127;
END meu_pacote;

USE work.meu_pacote.all;

ENTITY minha_entidade IS
PORT(
    entrada : in \textbf{meu_inteiro};
    saida: out \textbf{meu_inteiro} );
END minha_entidade;
\end{verbatim}

\subsection{Sintetização}

Por ser uma linguagem muito abrangente e complexa, algumas das funcionalidades possíveis na linguagem podem não ser possíveis na implementação física, como leitura de arquivos. Portanto é importante considerar o circuito real desejado. A ferramenta de síntese e simulação também deve ser considerada, pois a mesma pode aceitar diversos comandos irrealizável no mundo real.

A sintetização ocorre em várias etapas para levar a descrição do nível de abstração da linguagem até o circuito real. Os fabricantes de dispositivos reprogramáveis (FPGAs) costumam fornecer ferramentas que fazem todo o processo automaticamente. Esses níveis geralmente são:
\begin{enumerate}
\item { Análise }

Verificação de sintaxe, tipos e hierarquia do código, semelhante a uma primeira passagem de um compilador. A ferramenta de síntese pode também gerar uma descrição VHDL mais simplificada nessa etapa através de iterações, traduzindo macros para estruturas mais simples até obter uma descrição sintetizável.

\item { Geração de circuito RTL (\textit{Register Transfer Level}) }

É gerado um circuito de primitivas genéricas no sintetizador, como contadores, somadores e portas lógicas 

\item { Portas }

As primitivas genéricas são substituídas por componentes reais do dispositivo empregado, como flip-flops, carrys e latches.


\item { \textit{Place and Route} }

Com a descrição de componentes e ligações entre os mesmos, o sintetizador faz o posicionamento das primitivas em um dispositivo, utilizando os componentes e ligações disponíveis.

\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/sintetizacao_VHDL.jpg}
\caption{Síntese de uma descrição VHDL}
\label{fig:exemplo_concorrencia}
\end{figure}



\subsection{Simulação}

LEMBRAR DE ESCREVER AQUI!!


\section{Aquisição de imagens}

As imagens necessárias para o processamento devem ser obtidas adequadamente à velocidade do processo em questão. Apesar do processo de soldagem não ser muito rápido se comparado à velocidade de circuitos digitais, a obtenção das informações úteis não é trivial. As melhores imagens para identificação de parâmetros só são visíveis por curtos períodos de tempo durante o momento de curto-circuito da solda, não mais que alguns milissegundos.

% mostrar imagem de curto-circuito vs imagem normal

Câmeras comuns não são capazes de registrar estas imagens, pois não conseguem transmitir os dados de forma suficientemente rápida. O curto-circuito começa e acaba antes que a câmera transmita um \textit{frame} inteiro. O mais comum nesse caso é uma imagem com brilho excessivo provindo do arco de solda que dura muito mais tempo que o curto-circuito.


Algumas câmeras especiais, desenvolvidas para uso industrial ou pesquisa científica, são capazes de registrar \textit{frames} em períodos extremamente reduzidos de tempo. Estas possuem alta taxa de captura de imagens e consequentemente uma alta taxa de transmissão de dados. Este é o caso da câmera DALSA DS-21-0001M150, utilizada neste trabalho, que possui uma taxa máxima de amostragem de 150 fps com resolução de 1 \textit{megapixel}(1024 x 1024 pixels). Com cada pixel representado em 8 níveis de cinza, a taxa de transmissão desta câmera é de 1200 Mb/s, ou aproximadamente 1,2 Gb/s. \cite{luciano}

\subsection{Camera Link}

Atualmente existem protocolos rápidos o suficiente para transmissão de dados à partir da ordem de 1 Gb/s, como a fibra ótica e os cabos ethernet Cat 6 e Cat 7. Mas a câmera em questão utiliza um outro protocolo padronizado especificamente para aplicação com câmeras, o \textit{Camera Link}. Este protocolo permite transmissão de até 6,8 Gb/s em uma configuração máxima de três \textit{Channel-links} e transmite até 80 bits por ciclo. Esta característica é muito interessante para uso com FPGAs pois tem um grau de paralelismo naturalmente superior à outros protocolos.

O Camera Link usa de um a três \textit{Channel-links}. Com apenas um é classificado como Configuração Base (\textit{Base Configuration}) e pode transmitir até 2,04 Gb/s. As outras configurações são a Média (\textit{Medium Configuration}) e a Completa (\textit{Full Configuration}) e transmitem 4,08 e 6,8 Gb/s respectivamente.


O \textit{Channel-link} é uma interface de comunicação com um par emissão e recepção. Ele recebe 28 bits e os transmite de forma serial em quatro canais de 7 bits e um canal de clock, todos em LVDS(\textit{Low Voltage Differential Signaling}). \cite{camera-link}


\subsubsection{Especificações}

A configuração base transmite 24 bits de dados do pixel mais 3 bits de validação e um bit reserva a cada ciclo de clock. Os bits de validação são \textit{Data Valid}, \textit{Line Valid} e \textit{Frame Valid}. As configurações média e completa utilizam doi e três \textit{Channel-links} respectivamente, duplicando ou triplicando a quantidade de bits transmitios simultaneamente. Elas podem omitir os bits de validação redundantes e transmitir até 80 bits de dados por ciclo \cite{camera-link}. Esta característica da interface \textit{Camera Link} a torna ideal para processamento com alto nível de paralelismo, como em FPGAs. 

A transmissão serial é feita com 7 bits em cada canal a cada ciclo de clock. O início de cada palavra fica no meio do valor alto do clock e o clock tem o período de valor alto maior que o de valor baixo na proporção 4:3. Esta configuração pode ser melhor observada na imagem \ref{fig:camera-link-serial}. \cite{camera-link-ip-core}

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{./Figuras/camera-link-serial.jpg}
\caption{Codificação de dados do \textit{Camera Link}}
\label{fig:camera-link-serial}
\end{figure}

Pode-se notar na imagem \ref{fig:camera-link-serial} que os dados de cada cor são distribuídos de forma complicada entre os quatro canais da interface. 

Os bits de validação dependem basicamente da câmera utilizada mas seguem sempre um mesmo padrão \cite{camera-link}:

\begin{itemize}
\item FVAL (\textit{Frame Valid}) tem o valor ALTO para linhas válidas e sem deslocamento entre a borda de subida de FVAL e o começo da primeira linha válida.
\item LVAL (\textit{Line Valid}) tem o valor ALTO para pixels válidos e sem deslocamento entre o começo de LVAL e o primeiro pixel válido.
\item DVAL (\textit{Data Valid}) tem o valor ALTO para dados válidos.
\end{itemize}

Estes bits podem ser melhor visualizados no manual do fabricante da câmera utilizada nos experimentos, conforme a imagem \ref{fig:bits-validacao-camera-freerunning} abaixo \cite{dalsa}:

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{./Figuras/bits-validacao-camera-freerunning.jpg}
\caption{Esquema de validação de dados da câmera DALSA DS-21-0001M150}
\label{fig:bits-validacao-camera-freerunning}
\end{figure}

A imagem \ref{fig:bits-validacao-camera-freerunning} demonstra com clareza os momentos de ativação e desativação dos bits de validação, além de outras características interessantes dessa transmissão de dados. O valor \textit{INTEGRATION} por exemplo se refere ao tempo de exposição da câmera, CPRE (\textit{Clocks after exposure of the sensor}) que é um tempo mínimo entre a exposição e o início da transmissão de dados e \textit{line pause} é o tempo entre uma linha e outra.

\subsection{Configuração da câmera}

A câmera é extremamente versátil e permite uma grande gama de configurações que podem inclusive alterar a duração de alguns tempos demonstrados na imagem \ref{fig:bits-validacao-camera-freerunning}. Algumas opções incluem \cite{dalsa}:

\begin{itemize}
\item Tempo de exposição - é a duração de tempo que a câmera recebe luz do ambiente externo a cada imagem. Normalmente, quanto maior for o tempo de exposição, maior o brilho das imagens obtidas;
\item \textit{Frame Time} - define o tempo de duração de cada frame, ou seu inverso: a taxa de aquisição da câmera, também chamada de FPS (\textit{Frames Per Second}). 
\item Dimensionamento de janela - é uma das funções mais interessantes dessa câmera, pois permite usar apenas setores de interesse dentro da janela da câmera. Isto permite a aquisição de imagens menores a uma taxa mais elevada de FPS. Por exemplo, pode ser transmitido um vídeo de 1024 x 1024 pixels (1 Mp) a 150 FPS ou um de 512 x 1024 pixels (0,5) Mp a 300 FPS.
\end{itemize}

Todos esses parâmetros podem ser definidos através de comunicação serial por um software fornecido pelo fabricante. As configurações ficam armazenadas na EEPROM (Electrically-Erasable Programmable Read-Only Memory) da câmera e continuam em vigor mesmo após a mesma ser desligada.
Isso significa que a câmera pode ser configurada com o software e utilizada para aquisição com outra interface mesmo após ser desligada.







\section{Filtro de Kalman}


Retirar ruídos dos dados gerados pelo processamento de imagens.
Geração do sinal de controle à partir dos vetores gerados pelo algoritmo de processamento.




