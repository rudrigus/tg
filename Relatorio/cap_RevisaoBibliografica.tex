%TCIDATA{LaTeXparent=0,0,relatorio.tex}
                      
\chapter{Revisão Bibliográfica}\label{CapRevisaoBibliografica}

\section{Processo de Soldagem GMAW}

O processo de soldagem GMAW do inglês \textit{Gas Metal Arc Welding}, também conhecido como MIG/MAG (\textit{Metal Inert Gas/Metal Active Gas}) é um dos processos de soldagem mais propícios para automação. Alguns aspectos básicos do processo GMAW concernentes ao problema aqui tratado serão detalhados e discutidos nos próximos subitens.

\subsection{Fundamentos}

O princípio da soldagem GMAW é a união de peças metálicas é devido ao aquecimento por um arco elétrico formado entre as mesmas e um eletrodo metálico nu e consumível, sendo todos os elementos envoltos por um gás ativo ou inerte. 

O arame de soldar desempenha duas funções: por um lado é o eletrodo que conduz corrente, por outro, é também, em simultâneo, o material de adição a ser inserido na poça de soldagem. Este arame é introduzido mecanicamente através de um alimentador motorizado o que caracteriza o processo como semi-automático quando operado por humanos. \cite{book:modenesi}

A figura \ref{fig:solda_gmaw} demonstra o processo de formação do cordão de solda e seus elementos principais.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/solda_gmaw}
\caption{Elementos básicos da soldagem GMAW \cite{book:intro-soldagem}.}
\label{fig:solda_gmaw}
\end{figure}


Um gás de proteção que flui através do bocal da tocha protege o arco elétrico e o material em fusão, podendo o mesmo ser inerte (MIG) ou ativo (MAG). Os gases inertes, tais como o argônio e o hélio, não entram em reação com o material em fusão e apenas protegem os materiais fundidos de contaminantes. Por outro lado, os gases ativos, não só interferem no próprio arco elétrico, como também reagem com o material em fusão. Um exemplo de gás ativo é uma mistura de dióxido de carbono ou oxigênio com argônio. O componente ativo tem influência, por exemplo, sobre a penetração e/ou a temperatura do banho de fusão.

Além disto, o gás também tem influência nas perdas de elementos químicos, na temperatura da poça de fusão, na sensibilidade à fissuração e na porosidade, bem como na facilidade da execução da soldagem em diversas posições. Os gases nobres (processo MIG) são preferidos por razões metalúrgicas, enquanto o CO2 puro, é preferido por razões econômicas. O processo MAG é utilizado somente na soldagem de materiais ferrosos, enquanto o processo MIG pode ser usado tanto na soldagem de materiais ferrosos quanto não ferrosos como Alumínio, Cobre, Magnésio, Níquel e suas ligas.

% A soldagem GMAW funciona com corrente contínua (CC), normalmente com o arame no pólo positivo. Essa configuração é conhecida como polaridade reversa. A polaridade direta é raramente utilizada por causa da transferência deficiente do metal fundido do arame de solda para a peça. São comumente empregadas correntes de soldagem de 50 A até mais que 600 A e tensões de soldagem de 18V até 50V \cite{book:modenesi}. Um arco elétrico autocorrigido e estável é obtido com o uso de uma fonte de tensão constante e com um alimentador de arame de velocidade constante. A corrente de soldagem controla fortemente a velocidade de fusão do arame. Além disso, a penetração, o reforço e a largura do cordão tendem a aumentar com a corrente quando as demais variáveis são mantidas constantes.





\subsection{Equipamentos}

O processo GMAW tem um conjunto específico de equipamentos. Por ser um processo semi-automático (ou completamente automático), possui mais componentes que métodos mais convencionais de soldagem como o eletrodo revestido e o oxiacetileno. % Essa necessidade de um equipamento mais completo tem o custo compensado pela grande produtividade.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/esquematico-GMAW}
\caption{Esquemático dos equipamentos da soldagem GMAW \cite{book:ivanguerra}.}
\label{fig:TochaEsquematico}
\end{figure}

Os equipamentos necessários para esse tipo de solda são \cite{book:modenesi} \cite{book:ivanguerra}:
\begin{itemize}
\item Fonte de energia

Este processo utiliza sempre corrente contínua. Dependendo do modo em que é feito o controle, pode ser necessário controlar a corrente ou a tensão fornecida pela fonte. É comum usar corrente constante ou tensão constante durante o processo;

\item Alimentador de arame

Existem diversos tipos de alimentadores com diferentes tipos de controle. O controle de alimentação do arame devem estar alinhados com o método de controle elétrico. Por exemplo: é possível usar alimentação constante de arame com tensão constante ou corrente constante e alimentação variável \cite{book:modenesi};
\item Fonte de gás protetor

Normalmente um cilindro de gás (ou gases) e reguladores de pressão e/ou vazão

\item Tocha de soldagem

Existem diferentes tipos de tocha para proporcionar o desempenho máximo na soldagem para diferentes tipos de aplicações. Elas variam desde tochas para ciclos de trabalho pesados para atividades envolvendo altas correntes até tochas leves para baixas correntes e soldagem fora de posição. Em ambos os casos estão disponíveis tochas refrigeradas a água ou secas (refrigeradas pelo gás de proteção), e tochas com extremidades retas ou curvas.

A tocha consiste em todo a aparato que é levado até o local de união das peças, seja pela mão de um operador ou uma máquina/robô. Ela contém os seguintes elementos básicos que podem ser vistos na figura \ref{fig:TochaEsquematico} \cite{book:ivanguerra}:
\begin{itemize}
\item Bocal: guia o gás para a junção, geralmente feito de cobre ou material cerâmico. Seu diâmetro deve ser compatível com a corrente de soldagem e o fluxo de gás;
\item Bico de contato: faz o contato elétrico com o eletrodo, feito de cobre;
\item Alavanca de comando ou Gatilho: Ativa a energização do circuito de soldagem, o alimentador de arame e o fluxo de gás.
\end{itemize}
\end{itemize}



\subsection{Monitoramento dos parâmetros de soldagem}

Diversas variáveis do processo GMAW podem ser ajustadas para uma boa soldagem do metal. Estas variáveis são a velocidade de alimentação do eletrodo, a distância do bocal à peça, o \textit{stickout}, a inclinação de trabalho do eletrodo, e o fluxo de gás. Essas variáveis requerem um monitoramento constante por parte do operador, ou por um equipamento automático, que é o escopo deste trabalho. A velocidade de soldagem, a posição de soldagem e o diâmetro do eletrodo também influenciam consideravelmente na geometria do cordão de solda.

Quando a soldagem é feita por um soldador, a posição em relação à poça de soldagem e às peças sendo soldadas é constantemente verificada e corrigida. Dessa forma é possível manter uma qualidade boa da solda mesmo com as limitações mecânicas do ser humano. Este processo de ajuste que o soldador faz durante o processo de soldagem tem a característica de um sistema de controle em malha fechada.

Quando o processo é automatizado alguns parâmetros podem ser avaliados em tempo real, como corrente e tensão do arco para se inferir sobre variações na qualidade da solda. Outras abordagens como métodos baseados em inteligência artificial foram utilizadas para determinar uma metodologia para selecionar parâmetros de soldagem. Esses métodos apresentam a inconveniência de serem aplicáveis apenas em configurações específicas de soldagem e de funcionarem em malha aberta. Uma alternativa é utilizar um sistema de visão computacional para obter medidas geométricas durante a formação da solda. \cite{article:balfour}




\section{Processamento de imagens}

As imagens capturadas em um processo de soldagem necessitam passar por um processamento para que os valores necessários sejam obtidos. Nesta seção será explicado como é feito esse processamento.

% usar mota, ze mauricio, Jones para 
% segundo J mota o processamento de imagens é blablabla

A área de processamento de imagens desperta interesse de estudiosos por ter diversas aplicações em duas principais categorias: (1) aprimoramento de informações pictóricas para interpretação humana; e (2) extração automática de dados relevantes à partir de uma cena \cite{oge}. A segunda categoria, que será utilizada neste trabalho, também pode ser designada como ''análise de imagens'', ''visão por computador'' ou ''reconhecimento de padrões''.

Diversas áreas se beneficiam de técnicas de processamento de imagens. Na medicina procedimentos computacionais melhoram o contraste, codificam níveis de intensidade para melhor interpretação e podem até mesmo calcular a quantidade de um determinado tipo de célula em uma imagem. Geógrafos fazem uso de técnicas semelhantes e podem determinar áreas de vegetação, desmatamento, e poluição \cite{gonzalez}. Existem muitos outros exemplos, que vão até o controle de qualidade e de processos.

\subsection{Elementos de sistemas de processamento de imagens}
Um sistema de processamento de imagens consiste alguns elementos básicos mostrados a seguir \cite{gonzalez}:
\begin{enumerate}
\item {Aquisição:

São necessários: um dispositivo físico sensível a uma faixa de frequência no espectro eletromagnético (preferencialmente a luz visível) que produza um sinal elétrico proporcional ao nível de energia detectado; e um digitalizador que converte o sinal elétrico analógico em um sinal digital.
}
\item{Armazenamento:

Um desafio em processamento de imagens, o armazenamento de imagens digitais requer muita memória RAM ou \it{frame buffers} (Armazenamento por curto tempo) e espaço em disco (Arquivamento). \textbf{Apesar de os computadores atuais não terem grandes problemas com armazenamento, alguns equipamentos podem não ter memória suficiente para a tarefa como, por exemplo, um microcontrolador.}
}

\item{Processamento:

É um procedimento algorítmico que normalmente é realizado via software. Em casos em que velocidade é um fator importante no processamento pode ser necessário o uso de hardware especializado. É a parte mais complexa do sistema, exige pesquisa e desenvolvimento. 
}
\item{Comunicação:

A transmissão de imagens digitais necessita de uma alta largura de banda. Técnicas de compressão de imagens costumam ser utilizadas para reduzir este problema. Em aplicações em tempo real é necessária a sincronização dos dados.
}
\item{Exibição:

Por fim, o resultado do processamento é exposto ao ser humano através de um monitor. Pode ser desnecessária a exibição de todas as imagens de um processo que for automático.
}

\end{enumerate}

O elemento mais importante neste trabalho, Processamento de Imagens,possui alguns passos fundamentais para se chegar ao objetivo proposto. São eles:

\begin{enumerate}
\item{\textbf{Pré-processamento}: tem por objetivo melhorar a qualidade da imagem para que os estágios seguintes tenham mais garantia de sucesso. Geralmente envolve técnicas de realce de contrastes, remoção de ruído e isolamento de regiões.}
\item{\textbf{Segmentação}: é a divisão da imagem pré-processada em partes ou objetos constituintes. Por exemplo, caracteres em uma imagem de texto. É uma das tarefas mais difíceis de se implementar  e geralmente é o que define se o processamento vai ter sucesso ou não.
}
\item{\textbf{Representação e descrição}: nesse estágio, os dados obtidos pela segmentação em forma de pixels passam a ser representados de forma fronteiras e/ou  regiões completas. A partir dessa representação, há a descrição de características quantitativas ou qualitativas, por exemplo, uma concavidade ou um buraco.
}
\item{\textbf{Reconhecimento e interpretação}: finalmente, os objetos descritos anteriormente devem ser reconhecidos como algum padrão ou um valor para então se fazer a interpretação de um conjunto de objetos reconhecidos e atribuir um significado a esse conjunto. Por exemplo, uma imagem da palavra ''sim'' deve conter os objetos reconhecidos como ''s'',''i'', ''m'' e ser interpretada com a palavra ''sim''.
}
\end{enumerate}

\begin{figure}[h]
\begin{center}
\includegraphics[scale = 0.7]{./Figuras/passos_fundamentais.jpg}
\caption{Passos Fundamentais em processamento de imagens digitais}\label{fig:passos_fundamentais}
\end{center}
\end{figure}

Todos esses passos são possíveis quando se tem uma \textbf{Base de conhecimento} prévia que fica codificada no sistema de processamento de imagens. Com esses conhecimentos sobre o problema em questão e os métodos disponíveis pode-se criar uma solução viável. Por exemplo, quando é conhecida a região da imagem que tem informações de interesses é mais fácil segmentar essa imagem.

\subsection{Realce de imagens}

O objetivo das técnicas de realce é obter uma imagem mais apropriada para uma aplicação específica por meio de técnicas de processamento. As técnicas escolhidas, assim como seus parâmetros e a ordem em que são aplicadas dependem completamente da aplicação.
Existem basicamente dois métodos de realce: \textbf{Métodos no domínio espacial} e \textbf{Métodos no domínio da frequência}.

Os métodos no domínio espacial operam diretamente sobre o agregado de pixels que compõem uma imagem. Funções de processamento de imagens no domínio espacial podem ser expressas como:

\begin{equation}
g(x,y)=T[f(x,y)]
\end{equation}

em que $f(x,y)$ é a imagem de entrada, $g(x,y) $ é a imagem processada e $T$ é um operador sobre $f$, definido sobre alguma vizinhança de $(x,y)$. $T$ pode operar sobre um conjunto de imagens de entrada, como será explicado mais adiante.

A estratégia é definir uma subimagem em torno de um pixel $(x,y)$ (quadrado, retângulo ou mesmo aproximação de um círculo) e aplicar a operação sobre essa subimagem para cada pixel da imagem e obter $g$ em cada posição correspondente. A vizinhança mais simples que pode ser definida tem tamanho $1\times 1$, e $T$ é uma \textit{transformação de níveis de cinza} ou \textit{processamento ponto-a-ponto} da forma:

\begin{equation}
s=T(r)
\end{equation}

em que $r$ e $s$ representam os níveis de cinza de $f(x,y)$ e $g(x,y)$, respectivamente. Este tipo de função permite operações como mudança de contraste, binarização de imagem ou limiarização.
Outra variedade de funções pode ser aplicada sobre a imagem ao se trabalhar vizinhanças maiores. Costuma-se utilizar uma janela ou \textit{máscara} em forma de matriz $3\times 3$ para se fazer operações. Essa técnica costuma ser chamada de \textit{filtragem}.

Os métodos no domínio da frequência se baseiam no teorema da convolução com um operador linear invariante com a posição $h(x,y)$ na forma:

\begin{equation}
g(x,y) = h(x,y)*f(x,y)
\label{eq:convolucao}
\end{equation}

ou, a partir do teorema da convolução, no domínio da frequência:

\begin{equation}
G(u,v)=H(u,v)F(u,v)
\end{equation}

em que $G$, $H$ e $F$ são transformadas de Fourier de $g$, $h$ e $f$, respectivamente. Similarmente aos sistemas lineares, a transformada $H(u,v)$ é chamada de \textit{função de transferência óptica}. A equação \ref{eq:convolucao} é um processo espacial análogo ao uso de máscaras e $h(x,y)$ costuma ser chamada de \textit{máscara de convolução espacial}.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale = 0.7]{Figuras/convolucao.png}
\caption{Máscara e vizinhança de pixel}\label{fig:convolucao}
\end{center}
\end{figure}

A seguir são detalhados os métodos de processamento utilizados neste trabalho.

\subsubsection{Limiarização}

Esta é um método espacial que consiste em separar uma imagem em diferentes níveis de cinza. O comum é ter apenas um limiar e dois níveis, o que constitui em uma binarização da imagem. A binarização pode ser feita de duas formas: transformar todos os pixels abaixo de um limiar em zero (preto) ou transformar todos os acima do limiar no nível máximo (branco).

O mais comum é a limiarização que transforma todos os pixels abaixo do limiar em preto e todos acima em branco, ou seja uma imagem binária.

A limiarização por ser feita com um limiar pré definido ou de forma automática. Um exemplo de limiarização automática é a de equilíbrio de histograma, onde um algoritmo é utilizado para separar equilibradamente os dois grupos de pixels mais claros e mais escuros.



\subsection{Distorção de perspectiva}

Imagens de objetos tridimensionais capturados por uma câmera podem ter suas dimensões distorcidas pois a imagem é uma projeção bidimensional de parte do objeto. Essa distorção pode tornar impossível a tarefa de medir corretamente dimensões do objeto em questão. 

A projeção que ocorre no caso de captura de imagem por uma câmera é do tipo cônica, e não cilíndrica, isso implica que objetos de dimensões iguais no mundo real que estejam a diferentes distâncias da câmera terão suas projeções com diferentes tamanhos na imagem. Além disso câmeras podem ficar em ângulos oblíquos em relação aos planos de interesse dos objetos e essa projeção oblíqua pode resultar em diferentes medidas em diferentes eixos.

Para eliminar o problema de distorção existem dois métodos comumente utilizados: visão estereoscópica e transformação de projeção. O método de visão estereoscópica, apesar de permitir gerar um objeto tridimensional virtual, foi descartado neste trabalho pois seria tecnicamente inviável. Em ambientes com um razoável controle, como manter a câmera fixa em relação ao objeto, a transformação de projeção é suficiente para se obter os dados necessários.

\begin{figure}[h!]
\begin{center}
\subfigure[\label{fig:ModeloPlanoCamera}]{
\includegraphics[scale = 0.7]{Figuras/ModeloPlanoCamera.jpg}}
\subfigure[\label{fig:Modelo1DimCamera}]{
\includegraphics[scale = 0.7]{Figuras/Modelo1DimCamera.jpg}}
\caption{(a) Modelo de câmera plana. (b) Modelo de câmera unidimensional. \cite{article:Criminisi}}\label{fig:ModeloCamera}
\end{center}
\end{figure}


\subsubsection{Coordenadas Homogêneas}

Matematicamente o modelo de câmera e de projeção pode ser definido por uma matriz de transformação $H$. Pontos do plano real, $\Pi$  são representados por vetores em letra maiúscula, $\textbf{X}$, e as imagens correspondentes, no plano $\pi$ são representadas por vetores de letra minúscula, $\textbf{x}$. A projeção de perspectiva dos pontos correspondentes é dada por \cite{chapter:Zisserman:23} :


\begin{equation}
\textbf{x} = T\textbf{X}
\label{eq:ModeloCamera}
\end{equation}

Onde $T$ é uma matriz $3 \times 3$ e ''$= $''  representa igualdade em escala. Os vetores de pontos são dados por: $\textbf{X} = (X_1,X_2,X_3)^T$ e $\textbf{x} = (x_1,x_2,x_3)^T$


O ponto da imagem, uma projeção, e representado por três coordenadas cartesianas, $\textbf{x} = (x_1,x_2,x_3)^T$. Essas coordenadas são chamadas de homogêneas. Apenas a direção do vetor é importante visto que, independente da distância da câmera, qualquer ponto real em determinada direção aparecerá em um único ponto na projeção. Portanto todos os pontos da forma $ \lambda \textbf{x} = (\lambda x_1, \lambda x_2, \lambda x_3)$ são equivalentes.

Para representar os pontos em um plano cartesiano convencional da forma $(x,y)$, deve-se construir um plano especial $\pi_e)$, perpendicular ao eixo $x_3$ a uma distância unitária na direção de $x_3$. A intersecção do vetor $\textbf{x}$ com o plano $\pi_e$ é o ponto $x_e = (x,y,1)$.

É de interesse que a posição desse plano não afete a posição das coordenadas cartesianas $(x,y)$, portanto definem-se essas coordenadas da seguinte forma:

\begin{equation}
x_e = (\frac{x_1}{x_3},\frac{x_2}{x_3},1)^T = (x,y,1)^T
\label{eq:xe}
\end{equation}



O modelo da câmera é completamente especificado pela matriz $T$, que pode ser calculada com a posição relativa dos dois planos e o ponto focal da câmera. Porém, essa matriz também pode ser calculada diretamente por correspondência entre pontos na imagem e pontos no mundo real. Esse cálculo é descrito na seção \ref{section:CalculoMatrizTransf}.



\subsubsection{Cálculo da matriz de transformação}\label{section:CalculoMatrizTransf}


A equação \ref{eq:ModeloCamera} pode ser melhor visualizada a seguir:

\begin{equation}
\begin{bmatrix} 
x_1 \\
x_2 \\
x_3
\end{bmatrix} 
 =
\begin{bmatrix} 
t_{11} & t_{12} & t_{13} \\
t_{21} & t_{22} & t_{23} \\
t_{31} & t_{32} & t_{33}
\end{bmatrix} 
\begin{bmatrix}
X_1 \\
X_2 \\
X_3
\end{bmatrix}
\label{eq:ModeloCamera-2}
\end{equation}


A escala $\lambda$ da matriz não afeta a equação, portanto apenas os oito graus de liberdade correspondentes à razão dos elementos da matriz são significantes.

À partir da equação \ref{eq:ModeloCamera-2}, cada correspondência entre pontos reais e pontos da imagem gera duas equações de coordenada cartesianas $\textbf{H}$. Para $n$ correspondências obtém-se um sistema com $2n$ equações com $8$ variáveis. Se $n = 4$, obtém-se a solução exata \cite{chapter:Zisserman:23}. Se $n > 4$, a matriz  é super-determinada e estima-se $\textbf{H}$ por minimização \cite{article:Criminisi}.%
% % MUITO IMPORTANTE!!! Significa que são necessários 4 pontos conhecidos no mundo real. Posso colocar uma escala sobre a peça para obter o modelo da câmera e fazer uma pré calibração

A representação em coordenadas cartesianas demonstra a natureza não linear da transformação:

\begin{align}
x = \frac{x_1}{x_3} = \frac{t_{11}X + t_{12}Y + t_{13}}{t_{31}X + t_{32}Y + t_{33}} \\
y = \frac{x_2}{x_3} = \frac{t_{21}X + t_{22}Y + t_{23}}{t_{31}X + t_{32}Y + t_{33}}
\end{align}

Para definir os elementos da matriz de transformação deve-se ter quatro correspondências de pontos entre plano real e projeção. Com a escala de $\textbf{T}$ arbitrária, e $t_{33}=1$, Têm-se os pontos representados por $(\lambda_i x_i, \lambda_i y_i, lambda_i)^T = T(X_i,Y_i,1)^T$. O sistema de equações lineares resultantes é:

\begin{equation}\label{eq:SistEqZisserman}
\begin{bmatrix}
X_1 & Y_1 & 1 & 0 & 0 & 0 & -x_1 X_1 & -x_1 Y_1 \\
0 & 0 & 0 & X_1 & Y_1 & 1 & -y_1 X_1 & -y_1 Y_1 \\
X_2 & Y_2 & 1 & 0 & 0 & 0 & -x_2 X_2 & -x_2 Y_2 \\
0 & 0 & 0 & X_2 & Y_2 & 1 & -y_2 X_2 & -y_2 Y_2 \\
X_3 & Y_3 & 1 & 0 & 0 & 0 & -x_3 X_3 & -x_3 Y_3 \\
0 & 0 & 0 & X_3 & Y_3 & 1 & -y_3 X_3 & -y_3 Y_3 \\
X_4 & Y_4 & 1 & 0 & 0 & 0 & -x_4 X_4 & -x_4 Y_4 \\
0 & 0 & 0 & X_4 & Y_4 & 1 & -y_4 X_4 & -y_4 Y_4 \\
\end{bmatrix}
\begin{bmatrix}
t_{11}\\
t_{12}\\
t_{13}\\
t_{21}\\
t_{22}\\
t_{23}\\
t_{31}\\
t_{32}\\
\end{bmatrix}
=
\begin{bmatrix}
x_1\\
y_1\\
x_2\\
y_2\\
x_3\\
y_3\\
x_4\\
y_4\\
\end{bmatrix}
\end{equation}

Esse sistema linear garante a solução para a matriz $\textbf{T}$, desde que nenhum grupo de três pontos sejam colineares.

Finalmente, para determinar a matriz de transformação, deve-se resolver a equação \ref{eq:SistEqZisserman} para $t_{11}$ a $t_{32}$. O sistema é do formato $ A \cdot T = B $, e pode ser calculado com a regra da matriz inversa. A solução segue-se na equação \ref{eq:solucao-transformada} abaixo:

\begin{equation}
T = A^{-1} \cdot B
\end{equation}

\begin{equation}\label{eq:solucao-transformada}
\begin{bmatrix}
t_{11}\\
t_{12}\\
t_{13}\\
t_{21}\\
t_{22}\\
t_{23}\\
t_{31}\\
t_{32}\\
\end{bmatrix}
=
\begin{bmatrix}
X_1 & Y_1 & 1 & 0 & 0 & 0 & -x_1 X_1 & -x_1 Y_1 \\
0 & 0 & 0 & X_1 & Y_1 & 1 & -y_1 X_1 & -y_1 Y_1 \\
X_2 & Y_2 & 1 & 0 & 0 & 0 & -x_2 X_2 & -x_2 Y_2 \\
0 & 0 & 0 & X_2 & Y_2 & 1 & -y_2 X_2 & -y_2 Y_2 \\
X_3 & Y_3 & 1 & 0 & 0 & 0 & -x_3 X_3 & -x_3 Y_3 \\
0 & 0 & 0 & X_3 & Y_3 & 1 & -y_3 X_3 & -y_3 Y_3 \\
X_4 & Y_4 & 1 & 0 & 0 & 0 & -x_4 X_4 & -x_4 Y_4 \\
0 & 0 & 0 & X_4 & Y_4 & 1 & -y_4 X_4 & -y_4 Y_4 \\
\end{bmatrix}
^{-1}
\cdot
\begin{bmatrix}
x_1\\
y_1\\
x_2\\
y_2\\
x_3\\
y_3\\
x_4\\
y_4\\
\end{bmatrix}
\end{equation}

\subsubsection{Minimização de erros da transformação}

Para que se minimizem as margens de erro da matriz de transformação $\textbf{T}$, são necessários mais de quatro correspondências de pontos. De modo geral, como demonstrado em \cite{article:Criminisi}, quanto mais pontos utilizados na determinação da matriz de transformação, menor é a incerteza. Para $n$ pontos, sistema de equações é semelhante à \ref{eq:SistEqZisserman}:

\begin{equation}
\begin{bmatrix}
X_1 & Y_1 & 1 & 0 & 0 & 0 & -x_1 X_1 & -x_1 Y_1 \\
0 & 0 & 0 & X_1 & Y_1 & 1 & -y_1 X_1 & -y_1 Y_1 \\
X_2 & Y_2 & 1 & 0 & 0 & 0 & -x_2 X_2 & -x_2 Y_2 \\
0 & 0 & 0 & X_2 & Y_2 & 1 & -y_2 X_2 & -y_2 Y_2 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
X_n & Y_n & 1 & 0 & 0 & 0 & -x_n X_n & -x_n Y_n \\
0 & 0 & 0 & X_n & Y_n & 1 & -y_n X_n & -y_n Y_n \\
\end{bmatrix}
\begin{bmatrix}
t_{11}\\
t_{12}\\
t_{13}\\
t_{21}\\
t_{22}\\
t_{23}\\
t_{31}\\
t_{32}\\
\end{bmatrix}
=
\begin{bmatrix}
x_1\\
y_1\\
x_2\\
y_2\\
\vdots \\
x_n\\
y_n\\
\end{bmatrix}
\end{equation}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsection{Detecção de cantos}\label{section:DeteccaoCanto}

Muitas tarefas em processamento de imagens requerem a identificação de elementos em imagens, como figuras geométricas, linhas e pontos. Existem diversos métodos e algorítimos para detecção de cantos, mas apenas o método de Harris \cite{article:Harris} será descrito nessa seção pois apresenta alta taxa de acerto e fácil implementação de paralelismo, que pode acelerar o processo em um FPGA.

\subsubsection{Detector de Moravec}

O algorítimo parte do princípio de diferenciação de intensidade em porções de imagens usado no detector de imagens de Moravec \cite{article:Moravec}. O detector de Moravec funciona considerando uma janela na imagem, e determina a mudança de intensidade da imagem que resulta do deslocamento dessa janela em várias direções. São feitas as seguintes considerações:

\begin{enumerate}
\item Se a imagem na janela é plana, (aproximadamente constante em intensidade), então todas os deslocamentos resultam em uma mudança pequena;
\item Se a janela de move ao longo de uma borda, então a mudança de intensidade é pequena, mas se o deslocamento for perpendicular à borda, a mudança é grande;
\item Se a janela contém um canto ou ponto isolado, então todas os deslocamentos resultam em uma grande mudança de intensidade. Portanto, um canto pode ser detectado quando a menor mudança produzida por qualquer deslocamento for grande.
\end{enumerate}

Foi feita a descrição matemática das considerações acima. Denotando as intensidades como $I$, a mudança $E$ produzida por um deslocamento $(x,y)$ é dada por:

\begin{equation}
E_{x,y} = \sum\limits_{u}^{v} w_{u,v} | I_{x+u,y+v} - I_{u,v} |^2
\end{equation}

Onde $w$ especifica a janela da imagem: é uma unidade dentro de uma região retangular específica, e zero fora dela. Os deslocamentos $(x,y)$, são do tipo ${(1,0),(1,1),(0,1),(-1,1)}$. Portando o detector de Moravec é basicamente: procurar por um máximo local em $min(E)$ acima de uma limite estabelecido.

\subsubsection{Detector de auto-correlação}

A performance do detector de Moravec contém uma série de erros conforme demonstrado em \cite{article:Harris}, que então os listou e fez as devidas correções:

\begin{enumerate}
\item \textbf{A resposta é anisotrópica porque apenas um grupo de deslocamentos discretos é considerado} - todos os possíveis deslocamentos podem ser cobertos fazendo uma expansão analítica em torno do centro de deslocamento.
\begin{equation}
E_{x,y} = \sum\limits_{u}^{v} w_{u,v} [I_{x+u,y+v} - I_{u,v}] ^2
= \sum\limits_{u}^{v} w_{u,v} [x X + y Y + O(x^2,y^2)]^2
\end{equation}

onde os primeiros gradientes são aproximados por
\begin{align*}
X = I \otimes (-1,0,1) \approx \delta I/\delta x
\\Y = I \otimes (-1,0,1)^T \approx \delta I/\delta y
\end{align*}

Então para pequenas mudanças, $E$ pode ser escrito
\begin{equation*}
E(x,y) = A x^2 + 2C x y + B y^2
\end{equation*}

onde
\begin{align*}
A = X^2 \otimes w
\\B = Y^2 \otimes w
\\ C = (X Y) \otimes w
\end{align*}

\item \textbf{A resposta é ruidosa porque a janela é binária e retangular} - usar uma janela circular suave, por exemplo uma Gaussiana:
\begin{equation*}
w_{u,v} = exp -(u^2+v^2)/2 \sigma^2
\end{equation*}

\item \textbf{O operador responde muito cedo a bordas porque o apenas o mínimo de $E$ é considerado} - reformular a medida de canto para usar a variação de $E$ com a direção do deslocamento. A mudança, $E$, para um pequeno deslocamento $(x,y)$ pode ser escrita como:
\begin{equation*}
E(x,y) = (x,y) M (x,y)^T
\end{equation*}

onde a matriz $M$, $2 \times 2$  simétrica é:
\begin{equation}
M = \begin{bmatrix}
A & C
\\ C & B
\end{bmatrix}
\end{equation}
\end{enumerate} 

Os autovalores $\alpha$ e $\beta$ de $M$ correspondem à principais curvaturas da função de autocorrelação local. São três os casos em relação aos autovalores:

\begin{enumerate}
\item Se ambos são pequenos, a janela corresponde a uma imagem plana;
\item Se um é pequeno e o outro é grande, a janela corresponde a uma borda;
\item Se ambos são grandes, a janela corresponde a um canto.
\end{enumerate}

Com essas três considerações, se faz necessário uma medida também uma medida de qualidade de cantos. Calcula-se então uma medida $R$, função de $/alpha$ e  $/beta$. Para evitar a decomposição dos autovalores de $M$, usa-se o traço e a determinante da matriz, sendo que:
\begin{align*}
Tr (M) = \alpha + \beta = A + B
\\ Det (M) = \alpha \beta = A B - C^2
\end{align*}

Finalmente, Harris usou a seguinte formulação:
\begin{equation}
R = Det (M) - k Tr (M)^2
\end{equation}

Com essa formulação, pode-se definir o tipo da região localizada em $(u,v)$:

\begin{Bitemize}
\item Canto, se $R$ é positivo;
\item Borda, se $R$ é negativo;
\item Região plana, se $R$ é pequeno.
\end{Bitemize}

Como $R$ pode assumir uma grande gama de valores para diferente regiões da imagens utiliza-se limiares para definição dessas regiões. Isto gera a identificação de cinco regiões diferentes: fundo, duas classes de canto e duas de bordas. Quando o objetivo é apenas encontrar cantos, somente dois limiares são necessários.

\subsection{Perfis Verticais e Horizontais}\label{section:rev-perfis}

Uma das ferramentas para se encontrar elementos em imagens é perfil vertical e horizontal da imagem, ou perfis X e Y \cite{book:galbiati}. Esses perfis consistem basicamente na soma dos valores de pixels de linhas (perfil horizontal) ou colunas (perfil vertical) de uma imagem.

Esses perfis normalmente são armazenados em vetores para  comparação, visualização ou extração de informações. Por exemplo: o valor máximo de um perfil horizontal pode identificar a linha onde se encontra a maior largura de um objeto na imagem.

Com os vetores de perfis também pode-se utilizar suas derivadas. Como esses vetores são discretos, as derivadas são apenas o resultado da subtração de um elemento pelo elemento consecutivo.

Desta forma, podem ser criados pares de vetores com estes valores. As quantidades de elementos desses vetores correspondem a quantidade de linhas e colunas da imagem.


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 



\section{Sistemas reconfiguráveis}

Os custos para se testar circuitos na indústria de eletrônicos são muito elevados, pois é necessário fazer todo o \textit{setup} do processo de produção para um novo circuito. Por esse motivo foi desenvolvida a FPGA, ou \textit{Field Programable Gate Array}, que é um circuito reconfigurável que pode rapidamente assumir as características de um circuito digital, com todas as suas ligações e portas lógicas.

\begin{figure}[h]
\centering
\includegraphics[width=.7\textwidth]{./Figuras/Cyclone-II-DE2-115.jpg}
\caption{Placa Altera DE2, com FPGA Cyclone II \cite{online:terasic-de115}}
\label{fig:Altera-DE2}
\end{figure}


\subsection{História}

Os primeiro dispositivo programáveis foi o \textit{Programmable Read Only Memory}(PROM) , uma memória não volátil que podia ser do tipo fabricado em massa ou programável em campo pelo usuário. Por sua vez o tipo o PROM reconfigurável em campo tinha duas subdivisões: EPROM (\textit{Erasable} PROM) e EEPROM (\textit{Electronic Erasable} PROM), que pode ser reprogramado múltiplas vezes. Em seguida foram criados os \textit{Programmable Logic Devices} (PLDs), em que o tipo mais comum implementa um conjunto fixo de portas OR precedido por uma matriz de portas AND programáveis. \cite{online:wayback}

Em 1985, a empresa Altera criou o primeiro dispositivo reprogramável da indústria, o chip EP300, Os usuários poderiam apagar as células EPROM do EP300 ao emitir luz ultravioleta através de uma janela de quartzo acima do circuito. A opção meramente conveniente à época se mostraria um grande elemento na indústria. \cite{online:altera-in-the-beginning}

\begin{figure}[h]
\centering
\includegraphics[width=.5\textwidth]{./Figuras/ep300.jpg}
\caption{EP300 da Altera \cite{online:altera-in-the-beginning}}
\label{fig:ep300}
\end{figure}


As FPGAs foram desenvolvidas como uma evolução dos PLDs, mais especificamente dos PLAs \textit{Programmable Logic Arrays} (PLAs), como descrito em \cite{page1985re}. Em 1985 a empresa Xilinx criou a primeira FPGA comercial \cite{periodic:xcell},  com portas e interconexões reprogramáveis.
Contudo, foi durante a década de 1990 que esses dispositivos ficaram famosos e assumiram diversas aplicações.

Atualmente os sistemas reconfiguráveis continuam em alta, principalmente agora que as tecnologias de fabricação estão próximas do limite de miniatuzação. A evolução do poder de processamento de arquiteturas convencionais (Arquitetura de Von Neumann), baseadas em um \textit{hardware} genérico que recebe fluxos de instruções, demonstra desaceleramento \cite{thesis:moore-law-limit}. Com o esperado limite da Lei de Moore  \cite{article:moore-cramming-components} , muitos projetistas recorrem ao uso de \textit{hardware} específico para solucionar diferentes problemas. 

As FPGAs atuais são produzidas com uma série de facilidades que incluem: memória, entradas e saídas de alta velocidade e blocos lógicos. Elas podem tanto ser utilizadas para desenvolvimento e teste de circuitos digitais (motivo pelo qual foram desenvolvidas) como podem ser implementadas no produto final. As aplicações vão desde processamento de imagens à mineração de \textit{bitcoins}.

\subsection{Aspectos Gerais}

De acordo com a patente de \textit{Re-programmable PLA} \cite{page1985re} os \textit{Programmable Gate Arrays} (PLAs) reconfiguráveis são descritos abaixo:

\begin{quote}
Em geral, um PLA é um circuito lógico que recebe uma pluralidade de sinais digitais de entrada e gera uma pluralidade de sinais digitais de saída onde cada um dos sinais de saída é uma combinação de soma-de-produto programável dos sinais de entrada. Em PLAs convencionais, um circuito é fornecido para gerar uma pluralidade de termos que são o E lógico de sinais de entrada selecionados; e um outro circuito é fornecido para gerar os sinais de saída ao operar seletivamente esses termos com OU ou E lógicos.
Um PLA típico pode ter um total de $x$ sinais de entrada, gerar um total de $y$ termos ''E'' à partir dos sinais de entrada, e gerar um total de $2$ sinais de saída ao operar seletivamente os termos $y$ com um OU lógico.
\end{quote}


Outras tecnologias de semicondutores reprogramáveis também foram desenvolvidas, como os  \textit{Application Specific Integrated Circuits} (ASICs), onde o dispositivo é desenvolvido apenas para um tipo de aplicação. Ainda há uma subdivisão dentro das FPGAs:

\begin{Bitemize}
\item \textit{One-Time Programmable} (OTP), que funciona como um ASIC depois de programado;
\item SRAM-\textit{based}, que pode ser reconfigurado múltiplas vezes e é o tipo mais utilizado.
\end{Bitemize}

Os elementos básicos de um FPGA são \cite{book:FPGA-system-design}:

\begin{itemize}
\item Combinação lógica
\item Interconexão
\item Blocos de entrada e saída
\end{itemize}

A arquitetura geral com os elementos básicos pode ser visto na figura \ref{fig:esquema-FPGA}. A lógica combinacional é dividida em blocos pequenos, chamados de CLBs (\textit{Combinational Logic Blocks}) ou LE (\textit{Logic Elements}). O CLB ou LE realiza operações simples com uso de portas lógicas e flip-flops.

As interconexões são feitas entre elementos lógicos e/ou entre portas de entrada e saída por meio de conexões programáveis. A interconexão pode ser logicamente organizada em canais ou outras unidades. Sinais importantes como um clock podem ser ligados a vários (até mesmo a todos) elementos.

Os pinos de entrada e saída são representados por blocos de entrada e saída, IOB (\textit{I/O Blocks}). Esses blocos podem ser configurados para receber ou fornecer sinais ao meio exterior.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/esquema-FPGA.jpg}
\caption{Arquitetura geral de uma FPGA \cite{book:FPGA-system-design}}
\label{fig:esquema-FPGA}
\end{figure}

%\subsection{Módulos especiais}
%
%% mostrar todos aqui
%
%Em caso geral, as FPGAs também vêm equipadas com módulos especiais que seriam de difícil implementação por parte do desenvolvedor ou mesmo impossíveis devido às restrições da própria arquitetura. A quantidade e variedade desses módulos varia bastante de placa para placa. Alguns dos mais comuns foram utilizados neste projeto e serão aqui descritos.
%
%\subsubsection{PLL}
%
%A PLL, ou \textit{Phase-locked loop}, é um módulo capaz de sincronizar diferentes interfaces e um dos circuitos mais importantes na eletrônica de telecomunicações. Basicamente, uma PLL gera um sinal de saída que é proporcional a um sinal de entrada.
%
%\subsubsection{Desserializador}
%
%\subsubsection{Memória}

% % % %        % % % %         % % % %       % % % %


\section{Linguagens de Descrição de Hardware e VHDL}
% falar sobre varias linguagens aqui e da vhdl so no desenv
% colocar imagens

Uma linguagem de descrição de hardware, ou HDL (\textit{Hardware Description Language}) é semelhante a uma linguagem de programação em termos de sintaxe e estrutura, porém como o próprio nome diz ela serve mais para descrever do que para programar. Esse tipo de linguagem tem por objetivo facilitar o projeto de circuitos eletrônicos, com uma descrição formal e precisa. Uma HDL padronizada permite a intercambialidade de informações entre diferentes fabricantes e projetistas além da automatização de simulação e síntese de circuitos. Existem variadas HDLs, dentre as quais foi escolhida a VHDL para este trabalho por motivos a serem expostos adiante.

\subsection{História do VHDL}

O surgimento do VHDL se deve à necessidade do \textit{Defense Advanced Research Projects Agency} (DARPA) em desenvolver uma ferramenta de projeto e documentação para o projeto VHSIC (\textit{Very High Speed Integrated Circuit}). O Departamento de Defesa definiu em 1983 os requisitos para uma linguagem de descrição padrão para circuitos e contratou as empresas IBM, Texas e Intermetrics para a tarefa. \cite{book:Amore}

A linguagem foi padronizada pelo IEEE (\textit{Institute of Electrical and Electronic Engineers}) com base na versão 7,2 e com o auxílio da empresa CLSI, contratada pela Força Aérea dos Estados Unidos. \cite{book:Amore} Em 1987, surgiu o padrão IEEE 1076-1987, denominado VHSIC \textit{Hardware Description Language} ou VHDL. A padronização da linguagem contou com a participação de profissionais de diversas áreas: design de sistemas de computadores, aeroespacial, comunicações, desenvolvedores de CAD, desenvolvimento de circuitos integrados etc. \cite{ieeeVHDL87}

Em 1993, o padrão 1076 recebeu uma revisão para facilitar ainda mais o trabalho de projetistas. A principal mudança era o melhor gerenciamento hierárquico de arquivos \cite{ieeeVHDL93-1076}. No mesmo ano surgiu o padrão 1164, que definia o pacote ''std\_logic\_1164'' que trouxe mais versatilidade ao modelamento por representar mais condições reais como alta impedância e nós não inicializados. O padrão 1164 é muito utilizado até os dias de hoje, principalmente depois de suas revisão em 2008 .

Em 1997, o surgiu mais um padrão, o 1076.3 \cite{ieee1997-1076.3}, que propôs novos tipos de dados como inteiros e reais, e novas funções como soma e multiplicação. Esses tipos são abstratos em código e um mero conjunto de bits no circuito real, porém a linguagem permite as operações apenas com variáveis de mesmo tipo. Essa padronização caracteriza o VHDL como uma linguagem fortemente tipada.



\subsection{Aspectos gerais da VHDL}

A linguagem VHDL, pode ser entendida tanto por máquinas quanto por humanos como na própria definição do IEEE \cite{ieee1997-1076.3}. Tem por objetivo organizar e documentar os projetos para diminuir o tempo de trabalho dos projetistas além de promover a rápida sintetização e de simulação de circuitos.

Uma das suas principais características é a alta hierarquização. É possível criar projetos com múltiplos níveis de hierarquia utilizando entidades (descrições de circuitos) dentro de entidades. Essa estrutura facilita o desenvolvimento partindo de níveis mais altos de abstração para níveis menores, com o método chamado \textit{top down} (muito comum nas linguagens de programação mais recentes). Também é usada a descrição do comportamento esperado do circuito.

Em um circuito sintetizado, a maioria dos comandos é executado concorrentemente, independente do nível hierárquico dos componentes e da ordem em que são declarados. 

Apesar disso é possível criar operações sequenciais tais como linguagens de programação em regiões específicas do código, nos subprogramas e processos. Essas estruturas são muito úteis para operações específicas como operações aritméticas mais complexas.

Algumas das características principais da linguagem são:

\begin{Bitemize}
\item \textit{Case-insensitive}, ou seja não identifica diferença entre caixa alta ou baixa em seu código;
\item Fortemente tipada;
\item Escalonável;
\item Hierárquica
\end{Bitemize}


\subsection{Entidades}

É uma abstração primária do VHDL.  As entidades podem ser instanciadas dentro de outras entidades, formando assim a hierarquia do projeto. Cada instância é vista pela entidade superior como uma caixa preta da qual se conhece apenas as entradas e saídas. A ferramenta de sintetização cria as instâncias à partir do nível mais alto da hierarquia, a Entidade de Projeto (ou \textit{Top Level Entity}).

Cada entidade deve ser declarada com a palavra reservada ''ENTITY'' seguida do nome que a identifica. Em seguida podem ser opcionalmente declaradas as cláusulas \textbf{}PORT'' ou ''GENERIC''. A cláusula ''PORT'' define os tipos de portas de entrada e saída da entidade. A cláusula ''GENERIC'' permite passar informações estáticas para uma entidade. Essas cláusulas são opcionais e podem ser omitidas, por exemplo em um \textit{testbench} usado para simulações.

%Cada porta tem um modo que define a direção e como os comandos na arquitetura podem operar com essas portas. Os modos são: ''in'', ''out'', ''buffer'', ''inout''.

O comportamento de uma entidade é definido pela arquitetura e precisa ser declarado com a palavra ''ARCHITECTURE''  seguida do nome dado a arquitetura e a identificação da entidade a qual ela está definindo. Em seguida, podem ser declarados sinais, constantes, subprogramas ou identificação de outras entidades que serão instanciadas dentro desta. Finalmente, a lógica  é descrita entre as palavras ''BEGIN'' e ''END'' da arquitetura, com todos os comandos, as operações e instanciações.

O exemplo abaixo mostra uma entidade que utiliza a instância de outras em seu código:

\begin{framed}
%colocar em uma folha só
\begin{lstlisting}[language=VHDL]
LIBRARY ieee ;
USE ieee.std_logic_1164.all ;
USE ieee.std_logic_arith.all;

ENTITY main is
    port (  CLOCK : in std_logic;
    start_stop    : in std_logic ;
    up_down       : in std_logic ;
    A, B, C, D, E, F, G, DP : out std_logic;
  );
        
        
END main ;

ARCHITECTURE ESTRUTURA of main is

SIGNAL BCD : std_logic_vector(3 downto 0);
SIGNAL bin4bits : integer(11 downto 0);
COMPONENT CONTADOR
PORT  ( 
  CLK   : in std_logic;
  start_stop    : in std_logic ;
  up_down       : in std_logic ;
  bin4bits      : out integer(3 downto 0)
  );
END component;

COMPONENT BIN_7SEG
PORT  ( 
  BIN : in std_logic_vector(3 downto 0);
  SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G, DP : out std_logic
  );
END component;

BEGIN
conta1 : CONTADOR port map (CLOCK, start_stop, up_down, bin4bits);
conv1 : BIN_7SEG port map (bin4bits, A, B, C, D, E, F, G, DP);
END ESTRUTURA;

\end{lstlisting}
\end{framed}


\subsubsection{Entidade de Projeto}

A entidade de projeto ou \textit{top level entity} é o nível mais alto na hierarquia de um projeto VHDL. Por convenção, o documento dessa entidade geralmente leva o nome do projeto e é por este documento que a ferramenta de sintetização começa a leitura.

Assim como outras entidades, a entidade de projeto tem entradas e saídas de diferentes tipos, porém estas não são utilizadas por outras entidades pois esta não está contida em nenhuma outra. As portas declaradas para essa entidade são diretamente relacionadas com o ambiente externo ao dispositivo. Por exemplo: são as portas desta entidade que o sintetizador usa para mapear os pinos de uma placa FPGA. Todas as outras portas de outras entidades são sinais internos à placa neste caso.

A arquitetura da entidade de projeto define o comportamento geral de todo o circuito, com as principais entidades que serão instanciadas e o relacionamento entre as mesmas. Em grandes projetos é comum não haver operações nesta entidade, somente ligações entre outras entidades e entre estas com o meio exterior.


\subsection{Bibliotecas e Pacotes}

O VHDL faz uso de bibliotecas para reaproveitar códigos e padronizar os projetos. Existem bibliotecas padrão como a IEEE, que possui diversos pacotes, como o 1076.3 e o 1164, que geralmente podem ser usados em um mesmo projeto. O projetista também pode definir bibliotecas próprias para fins de organização ou uso em outros projetos.

A maioria das bibliotecas precisam ser declaradas no início do código com a palavra chave ''LIBRARY'' para se ter acesso a suas definições e pacotes. Há duas bibliotecas que estão sempre disponíveis automaticamente sem necessidade de declaração nos documentos: a biblioteca padrão ''std'' e a biblioteca ''work''.

Os pacotes são definições que podem ser utilizadas em diferentes modelos definidos em diferentes arquivos e estão sempre contidos em alguma biblioteca. É um recurso que permite reutilizar código para poupar tempo e principalmente para manter a padronização de projetos. Em uma linguagem fortemente tipada, como é o caso do VHDL, é de suma importância a utilização de pacotes em detrimento de definições locais.

Existem diversos pacotes padrões, muitos dos quais distribuídos pelo IEEE, mas também há os pacotes definidos pelo próprio projetista como citado anteriormente.

Cada pacote utilizado precisa ser declarado no início do documento para se ter acesso aos elementos definidos no mesmo ao longo do código. É necessário declarar de antemão a biblioteca em que o pacote está contido, caso não esteja nas bibliotecas ''std'' ou ''work''. O exemplo abaixo permite acesso aos tipos e operações do pacote 1164 da IEEE:

\begin{framed}
\begin{lstlisting}[language=VHDL]
LIBRARY ieee;
USE ieee.std_logic_1164;
\end{lstlisting}
\end{framed}

Pacotes definidos pelo usuário precisam ser claramente identificados pela palavra chave ''package'' e ficam disponíveis para seus documentos dentro da biblioteca ''work'', a não ser que sejam explicitamente declaradas dentro de outra biblioteca definida pelo usuário. O exemplo abaixo mostra a declaração e utilização de um pacote:

\begin{framed}
\begin{lstlisting}[language=VHDL]
PACKAGE meu_pacote IS
  TYPE \textbf{meu_inteiro} IS range -127 to 127;
END meu_pacote;

USE work.meu_pacote.all;

ENTITY minha_entidade IS
PORT(
    entrada : in \textbf{meu_inteiro};
    saida: out \textbf{meu_inteiro} );
END minha_entidade;
\end{lstlisting}
\end{framed}

\subsection{Sintetização}

Por ser uma linguagem muito abrangente e complexa, algumas das funcionalidades possíveis na linguagem podem não ser possíveis na implementação física, como leitura de arquivos. Portanto é importante considerar o circuito real desejado. A ferramenta de síntese e simulação também deve ser considerada, pois a mesma pode aceitar diversos comandos irrealizáveis no mundo real.

A sintetização ocorre em várias etapas para levar a descrição do nível de abstração da linguagem até o circuito real. Os fabricantes de dispositivos reprogramáveis (FPGAs) costumam fornecer ferramentas que fazem todo o processo automaticamente. Esses níveis geralmente são:
\begin{enumerate}
\item { Análise }

Verificação de sintaxe, tipos e hierarquia do código, semelhante a uma primeira passagem de um compilador. A ferramenta de síntese pode também gerar uma descrição VHDL mais simplificada nessa etapa através de iterações, traduzindo macros para estruturas mais simples até obter uma descrição sintetizável.

\item { Geração de circuito RTL (\textit{Register Transfer Level}) }

É gerado um circuito de primitivas genéricas no sintetizador, como contadores, somadores e portas lógicas 

\item { Portas }

As primitivas genéricas são substituídas por componentes reais do dispositivo empregado, como \textit{flip-flops}, \textit{carrys} e \textit{latches}.


\item { \textit{Place and Route} }

Com a descrição de componentes e ligações entre os mesmos, o sintetizador faz o posicionamento das primitivas em um dispositivo, utilizando os componentes e ligações disponíveis.

\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./Figuras/sintetizacao_VHDL.jpg}
\caption{Síntese de uma descrição VHDL}
\label{fig:sintetizacao_VHDL}
\end{figure}


\subsection{Simulação}

Uma das ferramentas mais úteis para o desenvolvimento de qualquer sistema é o simulador que dá ao projetista a possibilidade de simular o projeto em suas várias etapas. Com as linguagens de descrição de hardware não é diferente. Geralmente os sintetizadores de VHDL ou Verilog também são vendidos ou distribuídos com algum simulador.

A princípio pode-se pensar que um simulador rodando em uma arquitetura de Von Neumann não será útil pois não tem a capacidade de processar na mesma velocidade que um \textit{hardware} de aplicação específica. Porém, o processo de compilação e escrita em uma placa FPGA tem um alto custo de tempo e o simulador normalmente é capaz de dar resultados satisfatórios apenas com uma sintetização a nível de RTL. Dessa forma é possível testar e corrigir rapidamente alterações no projeto.

% retirado a pedido do Guilherme
%\begin{figure}[h]
%\centering
%\includegraphics[width=\textwidth]{./Figuras/exemplo-simulacao-VHDL.jpg}
%\caption{Resultado de uma simulação em VHDL}
%\label{fig:exemplo_simulacao_VHDL}
%\end{figure}


A seguir serão descritos alguns aspectos de simuladores de forma sucinta.

\subsubsection{Funcionamento}

O simulador considera um circuito como uma coleção de sinais e processos. Sinais podem mudar de valor com o tempo sob o impacto de processos. Uma mudança de sinal é chamada de transação. \cite{manual:VHDL-simulation}

O que um simulador deve fazer em um determinado momento é indicado por uma lista de ações classificadas por tempo. Esta é a \textbf{lista de eventos}. Evento é a designação para uma mudança de sinal ou ativação de um processo em um momento específico. Por exemplo, se um processo que está ativo no momento $t = t_0$ tem o comando $a <= '1' \ after \ 10 ns$, então a transação $a <= '1'$ é colocada na lista de eventos no momento $t = t_0 + 10 ns$. \cite{manual:VHDL-simulation}

Uma transação nunca ocorre imediatamente, mesmo quando se o código não especificar nenhum atraso(\textit{after}). Portanto, uma transação é colocada na lista de eventos no momento $t = t_0 + \Delta$, em que $\Delta$ é zero (ou infinitesimalmente pequeno). Isso permite que processos que ocorrem simultaneamente sejam ordenados no tempo. Isto é possível porque $0 < \Delta < 2\Delta$ para o simulador. O conceito de infinitesimalmente pequeno é chamado de \textbf{atraso delta}. \cite{manual:VHDL-simulation}

A simulação começa com a criação da lista de eventos. Todos os processos da descrição VHDL são colocados na posição correta da lista. Durante a simulação a lista de eventos é processada em ordem temporal. Novos eventos que resultantes de transações são colocados na posição correta da lista. A simulação acaba quando a lista de eventos está vazia, quando é forçada a terminar(restrição de tempo) ou encontra um erro. \cite{manual:VHDL-simulation}

Este processo é chamado de simulação orientada a eventos (\textit{event-driven}) e é utilizada por praticamente todos os simuladores digitais. \cite{manual:VHDL-simulation}

\subsubsection{Estímulos de entrada}

Alem da descrição de \textit{hardware}, um simulador precisa dos sinais de entrada que influenciarão os processos.

Alguns softwares tem funções que ajudam o projetista a criar estímulos para o simulador, como um arquivo de formas de onda (\textit{waveform}). Esses arquivos são facilmente editáveis com funções simples para vetores de ondas como: \textit{clock}, contadores, valores aleatórios, textos ou edição manual feita visualmente. Estes arquivos são bastante úteis para o teste de blocos mais simples.

Porém, simulações mais detalhadas e extensas é mais comum o uso de \textit{testbenches}. Os \textit{testbenches} são arquivos criados em VHDL e aproveitam a própria estrutura e os elementos da linguagem para fornecer os valores desejados ao simulador. 

O mais comum é se construir um \textit{testbench} com uma entidade de projeto sem entradas ou saídas e apenas um componente que é a entidade de projeto a ser testada. Este componente costuma ser chamado de \textit{Design Under Test} (DUT), ou \textit{Design Under Verification} (DUV). Dessa forma é possível criar valores para todos os sinais de entrada do DUT dentro da arquitetura do \textit{testbench}.

Para alterar os valores de entrada com o tempo, podem ser utilizados os comandos ''after'' e ''wait''. Estes comandos, em conjunto com a estrutura do VHDL, os procedimentos e processos, permitem criar sinais síncronos ou assíncronos para fornecer dados de entrada a um \textit{testbench}. Pode-se criar um clock, por exemplo.

\subsubsection{Apresentação de resultados}

Os simuladores costumam apresentar os resultados da simulação em uma janela com as formas de onda dos sinais de saída do DUT. Para facilitar a leitura, os simuladores apresentam os valores sobre as ondas, ou ao lado destas. Se um vetor é representado, podem ser visualizadas as palavras binárias ou alguma decodificação destas, como valores decimais, hexadecimais, ou mesmo caracteres.

Em geral, pode-se remover ou adicionar outros sinais internos ao DUT, como saídas e entradas de entidades instanciadas no DUT ou mesmo sinais internos a estas instâncias. Esta funcionalidade é extremamente poderosa pois permite testar o funcionamento de todas as partes do projeto, independente do nível de hierarquia.


A figura \ref{fig:exemplo_simulacao_VHDL} demonstra a variação de diversos sinais ao longo do tempo em uma simulação. Pode-se ver na coluna mais à esquerda a lista de sinais escolhidos para se visualizar os resultados. A coluna à direita mostra as formas de onda desses sinais ao final da simulação. A coluna do meio mostra os valor assumido por cada sinal no momento marcado pela linha amarela na coluna à direita.



\section{Aquisição de imagens}\label{section:rev-aquisicao-imagens}

As imagens necessárias para o processamento devem ser obtidas adequadamente à velocidade do processo em questão. Apesar do processo de soldagem não ser muito rápido se comparado à velocidade de circuitos digitais, a obtenção das informações úteis não é trivial. As melhores imagens para identificação de parâmetros só são visíveis por curtos períodos de tempo durante o momento de curto-circuito da solda, não mais que alguns milissegundos.

\begin{figure}[h!]
\centering
\includegraphics[width=.6\textwidth]{./Figuras/camera-dalsa.png}
\caption{Câmera industrial}
\label{fig:camera-industrial}
\end{figure}


Câmeras comuns não são capazes de registrar estas imagens, pois não conseguem transmitir os dados de forma suficientemente rápida. O curto-circuito começa e acaba antes que a câmera transmita um \textit{frame} inteiro. O mais comum nesse caso é uma imagem com brilho excessivo provindo do arco de solda que dura muito mais tempo que o curto-circuito.


Algumas câmeras especiais, desenvolvidas para uso industrial ou pesquisa científica, são capazes de registrar \textit{frames} em períodos extremamente reduzidos de tempo. Estas possuem alta taxa de captura de imagens e consequentemente uma alta taxa de transmissão de dados. Este é o caso da câmera DALSA DS-21-0001M150 (figura \ref{fig:camera-industrial}), utilizada neste trabalho, que possui uma taxa máxima de amostragem de 150 fps com resolução de 1 \textit{megapixel}(1024 x 1024 pixels). Com cada pixel representado em 8 níveis de cinza, a taxa de transmissão desta câmera é de 1200 Mb/s, ou aproximadamente 1,2 Gb/s. \cite{luciano}

\subsection{Camera Link}

Atualmente existem protocolos rápidos o suficiente para transmissão de dados a partir da ordem de 1 Gb/s, como a fibra ótica e os cabos ethernet Cat 6 e Cat 7. Mas a câmera em questão utiliza um outro protocolo padronizado especificamente para aplicação com câmeras, o \textit{Camera Link}. Este protocolo permite transmissão de até 6,8 Gb/s em uma configuração máxima de três \textit{Channel-links} e transmite até 80 bits por ciclo. Esta característica é muito interessante para uso com FPGAs pois tem um grau de paralelismo naturalmente superior a outros protocolos.

O Camera Link usa de um a três \textit{Channel-links}. Com apenas um é classificado como Configuração Base (\textit{Base Configuration}) e pode transmitir até 2,04 Gb/s. As outras configurações são a Média (\textit{Medium Configuration}) e a Completa (\textit{Full Configuration}) e transmitem 4,08 e 6,8 Gb/s respectivamente.


O \textit{Channel-link} é uma interface de comunicação com um par emissão e recepção. Ele recebe 28 bits e os transmite de forma serial em quatro canais de 7 bits e um canal de clock, todos em LVDS(\textit{Low Voltage Differential Signaling}). \cite{camera-link}


\subsubsection{Especificações}

A configuração base transmite 24 bits de dados do pixel mais 3 bits de validação e um bit reserva a cada ciclo de clock. Os bits de validação são \textit{Data Valid}, \textit{Line Valid} e \textit{Frame Valid}. As configurações média e completa utilizam dois e três \textit{Channel-links} respectivamente, duplicando ou triplicando a quantidade de bits transmitios simultaneamente. Elas podem omitir os bits de validação redundantes e transmitir até 80 bits de dados por ciclo \cite{camera-link}. Esta característica da interface \textit{Camera Link} a torna ideal para processamento com alto nível de paralelismo, como em FPGAs. 

A transmissão serial é feita com 7 bits em cada canal a cada ciclo de clock. O início de cada palavra fica no meio do valor alto do clock e o clock tem o período de valor alto maior que o de valor baixo na proporção 4:3. Esta configuração pode ser melhor observada na figura \ref{fig:camera-link-serial}. \cite{camera-link-ip-core}

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{./Figuras/camera-link-serial.jpg}
\caption{Codificação de dados do \textit{Camera Link}}
\label{fig:camera-link-serial}
\end{figure}

Pode-se notar na figura \ref{fig:camera-link-serial} que os dados de cada cor são distribuídos de forma complicada entre os quatro canais da interface. 

Os bits de validação dependem basicamente da câmera utilizada mas seguem sempre um mesmo padrão \cite{camera-link}:

\begin{itemize}
\item FVAL (\textit{Frame Valid}) tem o valor ALTO para linhas válidas e sem deslocamento entre a borda de subida de FVAL e o começo da primeira linha válida.
\item LVAL (\textit{Line Valid}) tem o valor ALTO para pixels válidos e sem deslocamento entre o começo de LVAL e o primeiro pixel válido.
\item DVAL (\textit{Data Valid}) tem o valor ALTO para dados válidos.
\end{itemize}

Estes bits podem ser melhor visualizados no manual do fabricante da câmera utilizada nos experimentos, conforme a figura \ref{fig:bits-validacao-camera-freerunning} abaixo \cite{dalsa}:

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{./Figuras/bits-validacao-camera-freerunning.jpg}
\caption{Esquema de validação de dados da câmera DALSA DS-21-0001M150}
\label{fig:bits-validacao-camera-freerunning}
\end{figure}

A figura \ref{fig:bits-validacao-camera-freerunning} demonstra com clareza os momentos de ativação e desativação dos bits de validação, além de outras características interessantes dessa transmissão de dados. O valor \textit{INTEGRATION} por exemplo se refere ao tempo de exposição da câmera, CPRE (\textit{Clocks after exposure of the sensor}) que é um tempo mínimo entre a exposição e o início da transmissão de dados e \textit{line pause} é o tempo entre uma linha e outra.

\subsection{Configuração da câmera}

A câmera é extremamente versátil e permite uma grande gama de configurações que podem inclusive alterar a duração de alguns tempos demonstrados na figura \ref{fig:bits-validacao-camera-freerunning}. Algumas opções incluem \cite{dalsa}:

\begin{itemize}
\item Tempo de exposição - é a duração de tempo que a câmera recebe luz do ambiente externo a cada imagem. Normalmente, quanto maior for o tempo de exposição, maior o brilho das imagens obtidas;
\item \textit{Frame Time} - define o tempo de duração de cada frame, ou seu inverso: a taxa de aquisição da câmera, também chamada de FPS (\textit{Frames Per Second}). 
\item Dimensionamento de janela - é uma das funções mais interessantes dessa câmera, pois permite usar apenas setores de interesse dentro da janela da câmera. Isto permite a aquisição de imagens menores a uma taxa mais elevada de FPS. Por exemplo, pode ser transmitido um vídeo de 1024 x 1024 pixels (1 Mp) a 150 FPS ou um de 512 x 1024 pixels (0,5) Mp a 300 FPS.
\end{itemize}

Todos esses parâmetros podem ser definidos através de comunicação serial por um software fornecido pelo fabricante. As configurações ficam armazenadas na EEPROM (\textit{Electrically-Erasable Programmable Read-Only Memory}) da câmera e continuam em vigor mesmo após a mesma ser desligada.
Isso significa que a câmera pode ser configurada com o software e utilizada para aquisição com outra interface mesmo após ser desligada.


\section{Regressão Linear}

Regressão é uma ferramenta comum para diversos problemas em engenharia e estatística em geral. Uma regressão consiste basicamente em uma função matemática que descreve a relação entre duas variáveis sendo o comportamento de uma dependente da outra \cite{book:adv-eng-math}.

Em uma regressão, uma das variáveis, normalmente chamada de $x$, é tida como independente ou variável controlada. Esta variável pode ser medida com bom nível de exatidão. A outra variável, normalmente tida como $y$ é aleatória. O que se deseja obter é a função matemática $\mu(x)$ de dependência que $y$ tem em relação a $x$ \cite{book:adv-eng-math}.

Uma regressão linear é um caso específico, o mais simples dentre as regressões, e a função que se procura é uma linha reta da forma:

\begin{align}
\mu(x) = b + ax
\end{align}

O método mais utilizado para se encontrar a reta que melhor descreve uma sequencia com pontos do tipo $(x_1,y_1)$,$\cdots$,$(x_n,y_n)$ é o método dos Mínimos Quadrados Ordinários, ou MQO. O princípio é o seguinte: "A reta deve ser ajustada através dos pontos de modo que a soma dos quadrados das distâncias entre os pontos e a reta seja mínima, onde a distância é medida na vertical(enxo $y$)." \cite{book:adv-eng-math}

Além deste princípio é necessária mais uma condição para a solução matemática única deste método: "Os valores $x_1$,$\cdots$,$x_n$ na amostra ($x_1,y_1)$,$\cdots$,$(x_n,y_n)$ não podem ser todos iguais."\cite{book:adv-eng-math} 

À partir de uma amostra $(x_1,y_1)$,$\cdots$,$(x_n,y_n)$, descreve-se a seguinte linha, chamada \textbf{linha de regressão exemplo}:

\begin{align}
y = b + ax
\label{eq:linha-exemplo}
\end{align}

A distância vertical entre um ponto $(x_i,y_i)$ e a reta em \ref{eq:linha-exemplo} é dada por:

\begin{align}
|y_i - (b+ax_i)|
\end{align}

Portanto a soma dos quadrados dessas distâncias é 

\begin{align}
q = \sum_{i=1}^{n}(y_i - b - ax+i)^2
\label{eq:soma-erros-minimos-quadrados}
\end{align}

Para o MQO, deve-se determinar $a$ e $b$ de modo a minimizar o valor de $q$ na equação \ref{eq:soma-erros-minimos-quadrados}. Portanto:

\begin{align}
\frac{\partial q}{\partial a} = 0
\\\frac{\partial q}{\partial b} = 0
\label{eq:derivada-erros-minimos-quadrados}
\end{align}

A linha exemplo pode ser reescrita da forma:

\begin{align}
y - \bar{y} = a (x - \bar{x})
\label{eq:medias-minimos-quadrados}
\end{align}

Onde $\bar{x}$ e $\bar{y}$ são os valores médios de $x$ e $y$ na amostra. O coeficiente $a$ na equação \ref{eq:medias-minimos-quadrados} é chamado de corficiente de regressão e é dado por:

\begin{align}
a = \frac{s_{xy}}{x_x^2}
\label{eq:coeficiente-de-regressao}
\end{align}

A covariância de amostra $s_{xy}$ é:

\begin{align}
s_{xy} = \frac{1}{n-1}\sum_{i=1}^n(x_i-\bar{x})(y_i-\bar{y}) = \frac{1}{n-1} \left[\sum_{i=1}^n x_i y_i - \frac{1}{n} \left(\sum_{i=1}^n x_i\right) \left( \sum_{i=1}^n y_i\right) \right]
\label{eq:covariancia-amostra}
\end{align}

E a variância dos valores $x$, $s_x^2$ é dada por:

\begin{align}
s_{x}^2 = \frac{1}{n-1}\sum_{i=1}^n(x_i-\bar{x})^2 = \frac{1}{n-1} \left[\sum_{i=1}^n x_i^2 - \frac{1}{n} \left(\sum_{i=1}^n x_i\right)^2 \right]
\label{eq:variancia-amostra-x}
\end{align}

De \ref{eq:medias-minimos-quadrados} pode-se observar que a reta passa pelo ponto $\bar{x},\bar{y}$. Como $x$ é uma variável ordinária, será necessária também a variância dos valores $y$:


\begin{align}
s_{y}^2 = \frac{1}{n-1}\sum_{i=1}^n(y_i-\bar{y})^2 = \frac{1}{n-1} \left[\sum_{i=1}^n y_i^2 - \frac{1}{n} \left(\sum_{i=1}^n y_i\right)^2 \right]
\label{eq:variancia-amostra-y}
\end{align}

Ao se diferenciar a equação \ref{eq:soma-erros-minimos-quadrados} e se aplicar  \ref{eq:derivada-erros-minimos-quadrados} resulta em:

\begin{align}
\frac{\partial q}{\partial a} = -2 \sum(y_i - b -ax_i) = 0
\\\frac{\partial q}{\partial b} = -2 \sum x_i(y_i - b - a x_i) = 0
\label{eq:derivada-erros-minimos-quadrados-2}
\end{align}

Onde se soma de $i$ de  1 a $n$. Divide-se por 2, escreve-se cada lado das duas somas como três somas e leva-se as somas contendo $x_i$ e $x_iy_i$ para o lado direito. Então obtém-se as equações normais:

\begin{align}
b n + a \sum x_i = \sum y_i \\
b \sum x_i + a \sum x_i^2 = \sum x_i y_i 
\label{eq:derivada-erros-minimos-normais}
\end{align}


Este é um sistema linear de duas equações e duas variáveis e pode ser resolvido com a equação \ref{eq:sistema-linear-regressao} abaixo:

\begin{align}
\left| 
\begin{matrix}
n & \sum x_i \\
\sum x_i & \sum x_i^2
\end{matrix}
\right|
= n \sum x_i^2 - \left( \sum x_i \right) = n(n-1)s_x^2 = n \sum(x_i - \bar{x})^2
\label{eq:sistema-linear-regressao}
\end{align}

Este sistema tem solução única desde que sejam atendidas as condições necessárias. Dividindo-se a equação \ref{eq:sistema-linear-regressao} por $n$ e usando as médias, tem-se $b = \bar{y} - a \bar{x}$. 
%Junto com $y = b + ax$ isto dá \ref{eq:medias-minimos-quadrados}
Para se obter $a$, resolve-se \ref{eq:sistema-linear-regressao} com a regra de Cramer:

\begin{align}
a = \frac{n\sum x_i y_i - \sum x_i \sum y_i}{n(n-1)s_x^2}
\label{eq:solucao-regressao-a}
\end{align}



\subsection{Regressão Linear para FPGAs} \label{section:regressao-fpga}

A solução de uma regressão pelo método dos Mínimos Quadrados exige uma certa quantidade de cálculos computacionalmente custosos, como multiplicações e divisões. Quando se deseja ocupar poucos elementos em uma FPGA e reduzir a quantidade de operações, algumas simplificações podem ser feitas. Isto mostrado nesta seção.

De acordo com \cite{article:linear-regression-FPGA}, o primeiro passo é definir que os valores em $x$ são inteiros e começando à partir de 0. Desta a equação \ref{eq:soma-erros-minimos-quadrados} pode ser reescrita da seguinte forma:

\begin{align}
q = \sum_{i=0}^{n-1}(y_i - b - ax+i)^2
\label{eq:soma-erros-minimos-quadrados-fpga}
\end{align}

Ao se aplicar o quadrado e separar a equação \ref{eq:soma-erros-minimos-quadrados-fpga} em diferentes somas tem-se:

\begin{align}
q = \sum_{i=0}^{n-1}y_i^2 + a^2 \sum_{i=0}^{n-1} i^2 - 2a\sum_{i=0}^{n-1} i y_i + nb^2 + 2ab\sum_{i=0}^{n-1}i - 2b \sum_{i=0}^{n-1} y_i
\label{eq:soma-erros-minimos-quadrados-fpga-2}
\end{align}

Aplicando-se derivadas parciais na equação \ref{eq:soma-erros-minimos-quadrados-fpga-2}:

\begin{align}
\frac{\partial q}{\partial a} = 2a \sum_{i=0}^{n-1} i^2 -2\sum_{i=0}^{n-1} iy_i + 2b \sum_{i=0}^{n-1} i = 0 \\
a = \left( \sum_{i=0}^{n-1} iy_i -b \sum_{i=0}^{n-1} i  \right) / \sum_{i=0}^{n-1} i^2
\label{eq:derivada-erros-regressao-a}
\end{align}

\begin{align}
\frac{\partial q}{\partial b} = 2nb + 2a\sum_{i=0}^{n-1} i - 2\sum_{i=0}^{n-1} y_i = 0 \\
b = \left( 2\sum_{i=0}^{n-1} y_i -a\sum_{i=0}^{n-1} i\right)/n
\label{eq:derivada-erros-regressao-b}
\end{align}

No final tem-se:

\begin{align}
a = \left( n\sum_{i=0}^{n-1} iy_i - \sum_{i=0}^{n-1} y_i \sum_{i=0}^{n-1} i  \right) / \left( n\sum_{i=0}^{n-1} i^2 -\sum_{i=0}^{n-1} i \sum_{i=0}^{n-1} i\right)
\label{eq:regressao-fpga-a}
\end{align}

\begin{align}
b = \left( \sum_{i=0}^{n-1} y_i \sum_{i=0}^{n-1} i^2 - \sum_{i=0}^{n-1} iy_i \sum_{i=0}^{n-1} i  \right) / \left( n\sum_{i=0}^{n-1} i^2 -\sum_{i=0}^{n-1} i \sum_{i=0}^{n-1} i\right)
\label{eq:regressao-fpga-b}
\end{align}


Como visto nas equações \ref{eq:regressao-fpga-a} e \ref{eq:regressao-fpga-a}, ambos os coeficientes dependem da quantidade de pontos utilizados. São necessárias muitos somatórios com multiplicações e duas divisões.

Se esta quantidade for limitada para um valor constante $N$, obtém-se equações muito mais simplificadas, pois os somatórios que não dependem de $x$ ou $y$ passam a ter valores constantes. Esta limitação reduz boa parte dos cálculos dos fatores, incluindo os denominadores.

Considere-se que:

\begin{align}
\sum_{i=0}^{N-1} i = \frac{N^2}{2} -\frac{N}{2}
\end{align}

\begin{align}
\sum_{i=0}^{N-1} i^2 = \frac{N^3}{3} - \frac{N^2}{2} +\frac{N}{6}
\end{align}

Os coeficientes podem ser então encontrados apenas multiplicando-se constantes por somatórios e subtraindo resultados como pode ser visto em \ref{eq:const-reg-fpga-A} e \ref{eq:const-reg-fpga-B} \cite{article:linear-regression-FPGA}.


\begin{align}
a = \left(\frac{N}{N\sum i^2 - \sum i \sum i } \right) \cdot \sum_{i=0}^{N-1} i d_i
- \left(\frac{\sum i}{N\sum i^2 - \sum i \sum i } \right) \cdot \sum_{i=0}^{N-1} d_i
\label{eq:const-reg-fpga-A}
\end{align}

\begin{align}
b = \left(\frac{\sum i^2}{N\sum i^2 - \sum i \sum i } \right) \cdot \sum_{i=0}^{N-1} d_i
- \left(\frac{\sum i}{N\sum i^2 - \sum i \sum i } \right) \cdot \sum_{i=0}^{N-1} i d_i
\label{eq:const-reg-fpga-B}
\end{align}




%\subsection{Regressão Robusta}




